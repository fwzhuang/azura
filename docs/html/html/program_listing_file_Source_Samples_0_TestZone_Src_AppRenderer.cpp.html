

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File AppRenderer.cpp &mdash; Azura  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists\css\tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File AppRenderer.cpp" href="file_Source_Samples_1_ProceduralPlanet_Src_AppRenderer.cpp.html" />
    <link rel="prev" title="File AppRenderer.cpp" href="file_Source_Samples_0_TestZone_Src_AppRenderer.cpp.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Azura
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../setting-up.html">Setting Up</a></li>
<li class="toctree-l1"><a class="reference internal" href="../build-instructions.html">Build Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cmake-wrappers.html">CMake Wrappers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../projects.html">Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="apiRoot.html">Azura API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Azura</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="apiRoot.html">Azura API</a> &raquo;</li>
        
          <li><a href="file_Source_Samples_0_TestZone_Src_AppRenderer.cpp.html">File AppRenderer.cpp</a> &raquo;</li>
        
      <li>Program Listing for File AppRenderer.cpp</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/html/program_listing_file_Source_Samples_0_TestZone_Src_AppRenderer.cpp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-apprenderer-cpp">
<span id="program-listing-file-source-samples-0-testzone-src-apprenderer-cpp"></span><h1>Program Listing for File AppRenderer.cpp<a class="headerlink" href="#program-listing-for-file-apprenderer-cpp" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_Source_Samples_0_TestZone_Src_AppRenderer.cpp.html#file-source-samples-0-testzone-src-apprenderer-cpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">Source\Samples\0_TestZone\Src\AppRenderer.cpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#include &quot;TestZone/AppRenderer.h&quot;
#include &quot;Core/RawStorageFormat.h&quot;
#include &quot;Generic/RenderSystem.h&quot;
#include &quot;Generic/Shader.h&quot;
#include &quot;Memory/MemoryFactory.h&quot;
#include &quot;Memory/MonotonicAllocator.h&quot;
#include &quot;Math/Transform.h&quot;
#include &quot;Math/Icosphere.h&quot;
#include &quot;Math/Plane.h&quot;

#include &lt;algorithm&gt;
#include &lt;random&gt;

namespace Azura {
using namespace Containers; // NOLINT
using namespace Math;       // NOLINT
namespace {
  struct Vertex {
    float m_pos[4];
    float m_col[4];
  };

  struct VertexWithUV {
    float m_pos[4];
    float m_uv[2];
  };

  struct LightData {
    Vector4f m_lightPos;
  };

  constexpr U32 CLOTH_DIV_X = 30;
  constexpr U32 CLOTH_DIV_Y = 30;
} // namespace

AppRenderer::AppRenderer()
  : m_mainBuffer(0x640&#39;0000),
    m_mainAllocator(m_mainBuffer, 0x320&#39;0000),
    m_drawableAllocator(m_mainBuffer, 0x320&#39;0000),
    m_camera(1280, 720),
    m_clothPlane(Vector2f(-3.0f, -3.0f), Vector2f(3.0f, 3.0f), Vector2u(CLOTH_DIV_X, CLOTH_DIV_Y)),
    log_AppRenderer(Log(&quot;AppRenderer&quot;)) {
}

void AppRenderer::Initialize() {
  LOG_INF(log_AppRenderer, LOG_LEVEL, &quot;Starting Init of AppRenderer&quot;);

  HEAP_ALLOCATOR(Temporary, Memory::MonotonicAllocator, 16384);
  m_window = RenderSystem::CreateApplicationWindow(&quot;TestZone&quot;, 1280, 720);

  m_window-&gt;SetUpdateCallback([this](float deltaTime)
  {
    WindowUpdate(deltaTime);
  });

  m_window-&gt;SetKeyEventCallback([this](KeyEvent evt)
  {
    m_camera.OnKeyEvent(evt);
  });

  m_window-&gt;SetMouseEventCallback([this](MouseEvent evt)
  {
    UNUSED(evt);
    // Disable as it has bugs
    // m_camera.OnMouseEvent(e);
  });

  m_camera.SetZoom(10);
  m_camera.RotateAboutRight(-30);

  VERIFY_TRUE(log_AppRenderer, m_window-&gt;Initialize(), &quot;Cannot Initialize Window&quot;);

  ApplicationInfo appInfo;
  appInfo.m_name    = &quot;TestZone&quot;;
  appInfo.m_version = Version(1, 0, 0);

  DeviceRequirements requirements;
  requirements.m_discreteGPU   = true;
  requirements.m_float64       = false;
  requirements.m_int64         = false;
  requirements.m_transferQueue = false;

  m_camera.Recompute();

  m_clothUBO                     = {};
  m_clothUBO.m_model             = Matrix4f::FromTranslationVector(Vector3f(0, 3, 0));
  m_clothUBO.m_view              = m_camera.GetViewMatrix();
  m_clothUBO.m_viewProj          = m_camera.GetViewProjMatrix();
  m_clothUBO.m_invViewProj       = m_camera.GetInvViewProjMatrix();
  m_clothUBO.m_invProj           = m_camera.GetProjMatrix().Inverse();
  m_clothUBO.m_modelInvTranspose = m_clothUBO.m_model.Inverse().Transpose();

  m_sphereUBO                     = {};
  m_sphereUBO.m_model             = Matrix4f::Identity();
  m_sphereUBO.m_viewProj          = m_camera.GetViewProjMatrix();
  m_sphereUBO.m_view              = m_camera.GetViewMatrix();
  m_sphereUBO.m_invViewProj       = m_camera.GetInvViewProjMatrix();
  m_sphereUBO.m_invProj           = m_camera.GetProjMatrix().Inverse();
  m_sphereUBO.m_modelInvTranspose = m_sphereUBO.m_model.Inverse().Transpose();

  LightData lightData  = {};
  lightData.m_lightPos = Vector4f(0.0f, 15.0f, 0.0f, 1.0f);

  // TODO(vasumahesh1):[Q]:Allocator?
  const ApplicationRequirements applicationRequirements = {};

  TextureRequirements textureRequirements = {};
  textureRequirements.m_maxCount          = 1;
  textureRequirements.m_poolSize          = 0x400000; // 4MB

  DescriptorRequirements descriptorRequirements = DescriptorRequirements(3, 3, allocatorTemporary);
  // SET 0
  const U32 UBO_SLOT                            = descriptorRequirements.AddDescriptor({
    DescriptorType::UniformBuffer, ShaderStage::Vertex
  });
  const U32 LIGHT_SLOT = descriptorRequirements.AddDescriptor({
    DescriptorType::UniformBuffer, ShaderStage::Vertex
  });

  // SET 0 Compute
  m_computePass.m_computeUBOSlot = descriptorRequirements.AddDescriptor({
    DescriptorType::UniformBuffer, ShaderStage::Compute
  });

  const U32 UBO_SET   = descriptorRequirements.AddSet({UBO_SLOT});
  const U32 LIGHT_SET = descriptorRequirements.AddSet({LIGHT_SLOT});

  const U32 COMPUTE_UBO_SET = descriptorRequirements.AddSet({m_computePass.m_computeUBOSlot});

  ShaderRequirements shaderRequirements = ShaderRequirements(3, allocatorTemporary);
  const U32 COMPUTE_SHADER_ID            = shaderRequirements.AddShader({
    ShaderStage::Compute, &quot;Cloth.cs&quot;, AssetLocation::Shaders
    });

  const U32 VERTEX_SHADER_ID            = shaderRequirements.AddShader({
    ShaderStage::Vertex, &quot;Cloth.vs&quot;, AssetLocation::Shaders
  });
  const U32 PIXEL_SHADER_ID = shaderRequirements.AddShader({
    ShaderStage::Pixel, &quot;Cloth.ps&quot;, AssetLocation::Shaders
  });

  RenderPassRequirements renderPassRequirements = RenderPassRequirements(1, 2, 7, allocatorTemporary);
  renderPassRequirements.m_maxPools             = 2;

  const U32 DISTANCE_CONSTRAINTS_BUFFER = renderPassRequirements.AddBuffer({
    U32(sizeof(DistanceConstraint)) * U32(m_clothPlane.GetEdgeConstraints().size()), U32(sizeof(DistanceConstraint))
    });

  const U32 BEND_CONSTRAINTS_BUFFER = renderPassRequirements.AddBuffer({
    U32(sizeof(BendingConstraint)) * U32(m_clothPlane.GetBendingConstraints().size()), U32(sizeof(BendingConstraint))
    });

  const U32 COMPUTE_VERTEX_BUFFER = renderPassRequirements.AddBuffer({
    U32(sizeof(Vector4f)) * U32(m_clothPlane.GetVertices().size()), U32(sizeof(Vector4f))
    });

  const U32 COMPUTE_PROJECTION_BUFFER = renderPassRequirements.AddBuffer({
    U32(sizeof(Vector4f)) * U32(m_clothPlane.GetVertices().size()), U32(sizeof(Vector4f))
    });

  const U32 COMPUTE_VERTEX_VELOCITY = renderPassRequirements.AddBuffer({
    U32(sizeof(Vector4f)) * U32(m_clothPlane.GetVertices().size()), U32(sizeof(Vector4f))
    });

  const U32 COMPUTE_VERTEX_CONSTRAINT_COUNT = renderPassRequirements.AddBuffer({
    U32(sizeof(U32)) * U32(m_clothPlane.GetVertices().size()), U32(sizeof(U32))
    });

  const U32 COMPUTE_VERTEX_DELTAX = renderPassRequirements.AddBuffer({
    U32(sizeof(U32)) * U32(m_clothPlane.GetVertices().size()), U32(sizeof(U32))
    });

  const U32 COMPUTE_VERTEX_DELTAY = renderPassRequirements.AddBuffer({
    U32(sizeof(U32)) * U32(m_clothPlane.GetVertices().size()), U32(sizeof(U32))
    });

  const U32 COMPUTE_VERTEX_DELTAZ = renderPassRequirements.AddBuffer({
    U32(sizeof(U32)) * U32(m_clothPlane.GetVertices().size()), U32(sizeof(U32))
    });

  // const U32 COMPUTE_VERTEX_LOCK = renderPassRequirements.AddBuffer({
  //   U32(sizeof(U32)) * U32(m_clothPlane.GetVertices().size()), U32(sizeof(U32))
  //   });
  //
  // const U32 COMPUTE_VERTEX_DELTA = renderPassRequirements.AddBuffer({
  //   U32(sizeof(Vector4f)) * U32(m_clothPlane.GetVertices().size()), U32(sizeof(Vector4f))
  //   });

  m_computePass.m_passId = renderPassRequirements.AddPass({
    PipelinePassCreateInfo::Shaders{COMPUTE_SHADER_ID},
    PipelinePassCreateInfo::InputTargets{},
    PipelinePassCreateInfo::InputBuffers{{DISTANCE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {BEND_CONSTRAINTS_BUFFER, ShaderStage::Compute}},
    PipelinePassCreateInfo::OutputTargets{},
    // PipelinePassCreateInfo::OutputBuffers{COMPUTE_VERTEX_BUFFER, COMPUTE_PROJECTION_BUFFER, COMPUTE_VERTEX_VELOCITY, COMPUTE_VERTEX_CONSTRAINT_COUNT, COMPUTE_VERTEX_LOCK, COMPUTE_VERTEX_DELTA},
    PipelinePassCreateInfo::OutputBuffers{COMPUTE_VERTEX_BUFFER, COMPUTE_PROJECTION_BUFFER, COMPUTE_VERTEX_VELOCITY, COMPUTE_VERTEX_CONSTRAINT_COUNT, COMPUTE_VERTEX_DELTAX, COMPUTE_VERTEX_DELTAY, COMPUTE_VERTEX_DELTAZ},
    PipelinePassCreateInfo::DescriptorSets{COMPUTE_UBO_SET},
    ClearData{{0.0f, 0.0f, 0.0f, 1.0f}, 1.0f, 0},
    BlendState{},
    RenderPassType::Compute
    });

  const U32 RENDER_PASS = renderPassRequirements.AddPass({
    PipelinePassCreateInfo::Shaders{VERTEX_SHADER_ID, PIXEL_SHADER_ID}, // SHADERS
    PipelinePassCreateInfo::InputTargets{},                             // INPUT TARGETS
    PipelinePassCreateInfo::InputBuffers{},                             // INPUT TARGETS
    PipelinePassCreateInfo::OutputTargets{},                                  // OUTPUT TARGETS
    PipelinePassCreateInfo::OutputBuffers{},                                  // OUTPUT TARGETS
    PipelinePassCreateInfo::DescriptorSets{UBO_SET, LIGHT_SET},         // DESCRIPTORS
    ClearData{{0.2f, 0.2f, 0.2f, 1.0f}, 1.0f, 0}
  });

  m_clothVertexVel.resize(m_clothPlane.GetVertices().size());
  m_clothProjectedPos.resize(m_clothPlane.GetVertices().size());

  std::vector&lt;Vector4f&gt; zeroBufferData = std::vector&lt;Vector4f&gt;(m_clothPlane.GetVertexCount(), Vector4f(0.0f));
  std::vector&lt;Vector4i&gt; zeroIntVecData = std::vector&lt;Vector4i&gt;(m_clothPlane.GetVertexCount(), Vector4i(0));
  std::vector&lt;U32&gt; zeroIntBuffer = std::vector&lt;U32&gt;(m_clothPlane.GetVertexCount(), 0);

  const SizeType totalConstraints = m_clothPlane.GetEdgeConstraints().size() + m_clothPlane.GetBendingConstraints().size();
  for(SizeType i = 0; i &lt; totalConstraints; ++i)
  {
    m_clothConstraintsIdx.push_back(i);
  }

  for (auto&amp; velocity : m_clothVertexVel) {
    velocity = Vector4f(0, 0, 0, 0);
  }

  m_renderer = RenderSystem::CreateRenderer(appInfo, requirements, applicationRequirements,
                                            m_window-&gt;GetSwapChainRequirements(), renderPassRequirements,
                                            descriptorRequirements, shaderRequirements, m_mainAllocator,
                                            m_drawableAllocator,
                                            *m_window);

  m_textureManager = RenderSystem::CreateTextureManager(textureRequirements);

  const auto clothDataStart = reinterpret_cast&lt;const U8*&gt;(m_clothPlane.GetVertices().data()); // NOLINT
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_BUFFER, clothDataStart);

  const auto projectionStart = reinterpret_cast&lt;const U8*&gt;(zeroBufferData.data()); // NOLINT
  m_renderer-&gt;BindBufferTarget(COMPUTE_PROJECTION_BUFFER, projectionStart);
  // m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_DELTA, projectionStart);

  const auto distanceConstraintStart = reinterpret_cast&lt;const U8*&gt;(m_clothPlane.GetEdgeConstraints().data()); // NOLINT
  const auto bendConstraintStart = reinterpret_cast&lt;const U8*&gt;(m_clothPlane.GetBendingConstraints().data()); // NOLINT
  m_renderer-&gt;BindBufferTarget(DISTANCE_CONSTRAINTS_BUFFER, distanceConstraintStart);
  m_renderer-&gt;BindBufferTarget(BEND_CONSTRAINTS_BUFFER, bendConstraintStart);

  const auto velocityStart = reinterpret_cast&lt;const U8*&gt;(m_clothVertexVel.data()); // NOLINT
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_VELOCITY, velocityStart);

  const auto bufferLock = reinterpret_cast&lt;const U8*&gt;(zeroIntBuffer.data()); // NOLINT
  // m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_LOCK, bufferLock);
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_CONSTRAINT_COUNT, bufferLock);

  const auto deltaStart = reinterpret_cast&lt;const U8*&gt;(zeroIntBuffer.data()); // NOLINT
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_DELTAX, deltaStart);
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_DELTAY, deltaStart);
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_DELTAZ, deltaStart);

  const auto totalThreads = U32(m_clothPlane.GetEdgeConstraints().size() + m_clothPlane.GetBendingConstraints().size());
  const U32 numBlocks = (totalThreads + DEFAULT_BLOCK_SIZE_X - 1) / DEFAULT_BLOCK_SIZE_X;

  ComputePoolCreateInfo computePoolInfo = {allocatorTemporary};
  computePoolInfo.m_byteSize            = 0xF00000;
  computePoolInfo.m_computePasses       = {{m_computePass.m_passId}, allocatorTemporary};
  computePoolInfo.m_launchDims          = ThreadGroupDimensions{numBlocks, 1, 1};

  ComputePool&amp; computePool = m_renderer-&gt;CreateComputePool(computePoolInfo);
  m_computePool            = &amp;computePool;

  const float distanceStiffnessPrime = 1.0f - std::pow(1.0f - DISTANCE_STIFFNESS, 1.0f / SOLVER_ITERATIONS);
  const float bendingStiffnessPrime = 1.0f - std::pow(1.0f - BENDING_STIFFNESS, 1.0f / SOLVER_ITERATIONS);

  m_computeUBO = {};
  m_computeUBO.m_numVertices = m_clothPlane.GetVertexCount();
  m_computeUBO.m_stretchStiffness = distanceStiffnessPrime;
  m_computeUBO.m_bendStiffness = bendingStiffnessPrime;
  m_computeUBO.m_timeDelta = 0.0f;
  m_computeUBO.m_numBlocks = numBlocks;
  m_computeUBO.m_numStretchConstraints = U32(m_clothPlane.GetEdgeConstraints().size());
  m_computeUBO.m_numBendConstraints = U32(m_clothPlane.GetBendingConstraints().size());

  const auto computeUBOStart = reinterpret_cast&lt;const U8*&gt;(&amp;m_computeUBO); // NOLINT
  computePool.BindUniformData(m_computePass.m_computeUBOSlot, computeUBOStart, sizeof(ComputeUBO));

  IcoSphere sphere(4);

  DrawablePoolCreateInfo poolInfo = {allocatorTemporary};
  poolInfo.m_byteSize             = sphere.TotalDataSize() + m_clothPlane.TotalDataSize() + 0x400000;
  poolInfo.m_numDrawables         = 2;
  poolInfo.m_renderPasses         = {{RENDER_PASS}, allocatorTemporary};
  poolInfo.m_drawType             = DrawType::InstancedIndexed;

  const auto VERTEX_SLOT = poolInfo.AddInputSlot({
    BufferUsageRate::PerVertex, {{&quot;POSITION&quot;, RawStorageFormat::R32G32B32A32_FLOAT}}, 0, BufferSource::StructuredBuffer
  });

  const auto NORMAL_SLOT = poolInfo.AddInputSlot({
    BufferUsageRate::PerVertex, {{&quot;NORMAL&quot;, RawStorageFormat::R32G32B32_FLOAT}}
  });

  DrawablePool&amp; pool = m_renderer-&gt;CreateDrawablePool(poolInfo);

  const auto uboDataBuffer   = reinterpret_cast&lt;U8*&gt;(&amp;m_clothUBO);  // NOLINT
  const auto sphereUBO       = reinterpret_cast&lt;U8*&gt;(&amp;m_sphereUBO); // NOLINT
  const auto lightDataBuffer = reinterpret_cast&lt;U8*&gt;(&amp;lightData);   // NOLINT
  // Create Drawable from Pool
  DrawableCreateInfo createInfo = {};
  createInfo.m_vertexCount      = m_clothPlane.GetVertexCount();
  createInfo.m_indexCount       = m_clothPlane.GetIndexCount();
  createInfo.m_instanceCount    = 1;
  createInfo.m_indexType        = RawStorageFormat::R32_UINT;

  const auto clothId = pool.CreateDrawable(createInfo);
  pool.BindVertexData(clothId, VERTEX_SLOT, COMPUTE_VERTEX_BUFFER, 0, m_clothPlane.VertexDataSize());
  pool.BindVertexData(clothId, NORMAL_SLOT, m_clothPlane.NormalData(), m_clothPlane.NormalDataSize());
  pool.SetIndexData(clothId, m_clothPlane.IndexData(), m_clothPlane.IndexDataSize());
  pool.BindUniformData(clothId, UBO_SLOT, uboDataBuffer, sizeof(SceneUBO));
  pool.BindUniformData(clothId, LIGHT_SLOT, lightDataBuffer, sizeof(LightData));

  DrawableCreateInfo sphereDrawableInfo = {};
  sphereDrawableInfo.m_vertexCount      = sphere.GetVertexCount();
  sphereDrawableInfo.m_indexCount       = sphere.GetIndexCount();
  sphereDrawableInfo.m_instanceCount    = 1;
  sphereDrawableInfo.m_indexType        = sphere.GetIndexFormat();

  DrawablePoolCreateInfo spherePoolInfo = {allocatorTemporary};
  spherePoolInfo.m_byteSize             = sphere.TotalDataSize() + 0x400000;
  spherePoolInfo.m_numDrawables         = 1;
  spherePoolInfo.m_renderPasses         = {{RENDER_PASS}, allocatorTemporary};
  spherePoolInfo.m_drawType             = DrawType::InstancedIndexed;

  const auto SPHERE_VERTEX_SLOT = spherePoolInfo.AddInputSlot({
    BufferUsageRate::PerVertex, {{&quot;POSITION&quot;, RawStorageFormat::R32G32B32A32_FLOAT}}
    });

  const auto SPHERE_NORMAL_SLOT = spherePoolInfo.AddInputSlot({
    BufferUsageRate::PerVertex, {{&quot;NORMAL&quot;, RawStorageFormat::R32G32B32_FLOAT}}
    });

  DrawablePool&amp; spherePool = m_renderer-&gt;CreateDrawablePool(spherePoolInfo);

  const auto sphereId = spherePool.CreateDrawable(sphereDrawableInfo);
  spherePool.BindVertexData(sphereId, SPHERE_VERTEX_SLOT, sphere.VertexData(), sphere.VertexDataSize());
  spherePool.BindVertexData(sphereId, SPHERE_NORMAL_SLOT, sphere.NormalData(), sphere.NormalDataSize());
  spherePool.SetIndexData(sphereId, sphere.IndexData(), sphere.IndexDataSize());
  spherePool.BindUniformData(sphereId, UBO_SLOT, sphereUBO, sizeof(SceneUBO));
  spherePool.BindUniformData(sphereId, LIGHT_SLOT, lightDataBuffer, sizeof(LightData));

  m_renderPass.m_vertexSlot = VERTEX_SLOT;
  m_renderPass.m_normalSlot = NORMAL_SLOT;
  m_renderPass.m_sceneUBOSlot = UBO_SLOT;
  m_renderPass.m_clothId      = clothId;
  m_renderPass.m_sphereId     = sphereId;

  m_mainPool = &amp;pool;
  m_spherePool = &amp;spherePool;

  // All Drawables Done
  m_renderer-&gt;Submit();

  LOG_INF(log_AppRenderer, LOG_LEVEL, &quot;Initialized AppRenderer&quot;);
}

void AppRenderer::WindowUpdate(float timeDelta) {
  if (timeDelta &lt; EPSILON)
  {
    return;
  }

  m_camera.Update(timeDelta);

   timeDelta = 0.0166667f;

  m_clothUBO.m_view              = m_camera.GetViewMatrix();
  m_clothUBO.m_viewProj          = m_camera.GetViewProjMatrix();
  m_clothUBO.m_invViewProj       = m_camera.GetInvViewProjMatrix();
  m_clothUBO.m_invProj           = m_camera.GetProjMatrix().Inverse();
  m_clothUBO.m_modelInvTranspose = m_clothUBO.m_model.Inverse().Transpose();

  m_sphereUBO.m_view              = m_camera.GetViewMatrix();
  m_sphereUBO.m_viewProj          = m_camera.GetViewProjMatrix();
  m_sphereUBO.m_invViewProj       = m_camera.GetInvViewProjMatrix();
  m_sphereUBO.m_invProj           = m_camera.GetProjMatrix().Inverse();
  m_sphereUBO.m_modelInvTranspose = m_sphereUBO.m_model.Inverse().Transpose();

  m_computeUBO.m_timeDelta = timeDelta;

  const auto uboDataBuffer    = reinterpret_cast&lt;U8*&gt;(&amp;m_clothUBO);          // NOLINT
  const auto sphereDataBuffer = reinterpret_cast&lt;U8*&gt;(&amp;m_sphereUBO);         // NOLINT
  const auto computeUBOStart = reinterpret_cast&lt;const U8*&gt;(&amp;m_computeUBO); // NOLINT

  m_computePool-&gt;BeginUpdates();
  m_computePool-&gt;UpdateUniformData(m_computePass.m_computeUBOSlot, computeUBOStart, sizeof(ComputeUBO));
  m_computePool-&gt;SubmitUpdates();

  m_mainPool-&gt;BeginUpdates();
  // Update Cloth
  m_mainPool-&gt;UpdateUniformData(m_renderPass.m_clothId, m_renderPass.m_sceneUBOSlot, uboDataBuffer, sizeof(SceneUBO));
  // Update Sphere
  m_mainPool-&gt;SubmitUpdates();

  m_spherePool-&gt;BeginUpdates();
  m_spherePool-&gt;UpdateUniformData(m_renderPass.m_sphereId, m_renderPass.m_sceneUBOSlot, sphereDataBuffer,
    sizeof(SceneUBO));
  m_spherePool-&gt;SubmitUpdates();

  m_renderer-&gt;RenderFrame();
}

void AppRenderer::Run() const {
  LOG_INF(log_AppRenderer, LOG_LEVEL, &quot;Running AppRenderer&quot;);
  m_window-&gt;StartListening();
}

void AppRenderer::Destroy() const {
  m_window-&gt;Destroy();
}
} // namespace Azura
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_Source_Samples_1_ProceduralPlanet_Src_AppRenderer.cpp.html" class="btn btn-neutral float-right" title="File AppRenderer.cpp" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_Source_Samples_0_TestZone_Src_AppRenderer.cpp.html" class="btn btn-neutral" title="File AppRenderer.cpp" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Vasu Mahesh

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/collapsible-lists\js\CollapsibleLists.compressed.js"></script>
        <script type="text/javascript" src="../_static/collapsible-lists\js\apply-collapsible-lists.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>