

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Flamenco &mdash; Azura  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists\css\tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Procedural Planet" href="procedural-planet.html" />
    <link rel="prev" title="Projects" href="../projects.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Azura
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../setting-up.html">Setting Up</a></li>
<li class="toctree-l1"><a class="reference internal" href="../build-instructions.html">Build Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cmake-wrappers.html">CMake Wrappers</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../projects.html">Projects</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Flamenco</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#description">Description</a></li>
<li class="toctree-l3"><a class="reference internal" href="#methodology">Methodology</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pbd-algorithm">PBD Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gpu-based-pbd-solver">GPU-Based PBD Solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#geometric-constraints">Geometric Constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#environment-collisions">Environment Collisions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mesh-definition">Mesh Definition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spatial-hashing-with-predictive-constraints-for-self-collisions">Spatial Hashing with Predictive Constraints for Self-Collisions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#compute-vertex-projected-positions">Compute Vertex Projected Positions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#binning-initialization">Binning Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vertex-binning">Vertex Binning</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generate-self-collision-constraints">Generate Self-Collision Constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#apply-vertex-constraints">Apply Vertex Constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#apply-deltas">Apply Deltas</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compute-vertex-positions">Compute Vertex Positions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mesh-normals">Mesh Normals</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shading-pass">Shading Pass</a></li>
<li class="toctree-l4"><a class="reference internal" href="#frame-timing-breakdown">Frame Timing Breakdown</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#performance">Performance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cpu-vs-gpu">CPU vs GPU</a></li>
<li class="toctree-l4"><a class="reference internal" href="#total-compute-time-vs-total-constraints-solved">Total Compute Time vs Total Constraints Solved</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mesh-resolution-vs-compute-time">Mesh Resolution vs Compute Time</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spatial-hash-grid-acceleration">Spatial Hash Grid Acceleration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#additional-features">Additional Features</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gltf-2-0-mesh-support">GLTF 2.0 Mesh Support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rendering-pipeline-using-pbr-shading">Rendering Pipeline using PBR Shading</a></li>
<li class="toctree-l4"><a class="reference internal" href="#meme-generator">Meme Generator</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="procedural-planet.html">Procedural Planet</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../html/apiRoot.html">Azura API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Azura</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../projects.html">Projects</a> &raquo;</li>
        
      <li>Flamenco</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Projects/cloth-sim.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="flamenco">
<h1>Flamenco<a class="headerlink" href="#flamenco" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>Vasu Mahesh<ul>
<li><a class="reference external" href="http://linkedin.com/in/vasumahesh">LinkedIn</a></li>
<li><a class="reference external" href="http://www.codeplaysleep.com">Code Blog</a></li>
</ul>
</li>
<li>Zach Corse<ul>
<li><a class="reference external" href="https://www.linkedin.com/in/wzcorse/">LinkedIn</a></li>
<li><a class="reference external" href="https://wzcorse.com">Personal Website</a></li>
</ul>
</li>
</ul>
<div class="section" id="description">
<h2>Description<a class="headerlink" href="#description" title="Permalink to this headline">¶</a></h2>
<p>Flamenco is a GPU position-based dynamics (PBD) cloth simulation sufficiently fast and robust for use in games. Our take on this well-studied problem is an amalgam of some of the industry’s best PBD cloth methods, some dating back as far as 2003, some recently communicated in GDC 2018, all mixed and ported to the GPU <a class="footnote-reference" href="#id7" id="id2">[1]</a> <a class="footnote-reference" href="#id8" id="id3">[2]</a>. By parallelizing these methods on the GPU, we achieve frame rates far higher than their CPU-based counterparts, and easily satisfy the game industry’s 60 fps standard.</p>
<img alt="Main GIF" src="../_images/default_cloth_30x30_(0.8-0.7-0.3).gif" />
</div>
<hr class="docutils" />
<div class="section" id="methodology">
<h2>Methodology<a class="headerlink" href="#methodology" title="Permalink to this headline">¶</a></h2>
<div class="section" id="pbd-algorithm">
<h3>PBD Algorithm<a class="headerlink" href="#pbd-algorithm" title="Permalink to this headline">¶</a></h3>
<p>We write the core PBD algorithm here for convenience <a class="footnote-reference" href="#id10" id="id4">[4]</a>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">ALGORITHM</span> <span class="n">Position</span> <span class="n">Based</span> <span class="nl">Dyanmics</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">all</span> <span class="n">vertices</span> <span class="n">i</span> <span class="k">do</span>
    <span class="n">initialize</span> <span class="n">x_i</span><span class="p">,</span> <span class="n">vi</span><span class="p">,</span> <span class="n">wi</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">mi</span>
  <span class="n">end</span> <span class="k">for</span>
  <span class="n">loop</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">vertices</span> <span class="n">i</span> <span class="k">do</span> <span class="n">vi</span> <span class="o">=</span> <span class="n">vi</span> <span class="o">+</span> <span class="n">wi</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">f_ext</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">vertices</span> <span class="n">i</span> <span class="k">do</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">xi</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">vi</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">vertices</span> <span class="n">i</span> <span class="k">do</span> <span class="n">genCollConstraints</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
    <span class="n">loop</span> <span class="n">solverIterations</span> <span class="n">times</span>
      <span class="n">projectConstraints</span><span class="p">()</span>
    <span class="n">end</span> <span class="n">loop</span>
    <span class="k">for</span> <span class="n">all</span> <span class="n">vertices</span> <span class="n">i</span> <span class="k">do</span>
      <span class="n">vi</span> <span class="o">=</span> <span class="p">(</span><span class="n">pi</span> <span class="o">-</span> <span class="n">xi</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span>
      <span class="n">xi</span> <span class="o">=</span> <span class="n">pi</span>
    <span class="n">end</span> <span class="k">for</span>
  <span class="n">end</span> <span class="n">loop</span>
<span class="n">END</span>
</pre></div>
</div>
</div>
<div class="section" id="gpu-based-pbd-solver">
<h3>GPU-Based PBD Solver<a class="headerlink" href="#gpu-based-pbd-solver" title="Permalink to this headline">¶</a></h3>
<a class="reference external image-reference" href="../_images/SolverPasses.PNG"><img alt="Solver Passes" src="../_images/SolverPasses.PNG" /></a>
<p>The PBD algorithm is typically evaluated on the CPU using a Gauss-Seidel type solver, which works exclusively in a serial fashion. Porting the PBD algorithm therefore requires a different approach. Researchers typically choose one of two methods - A Jacobi iterative solver or a graph coloring algorithm <a class="footnote-reference" href="#id9" id="id5">[3]</a>. The graph coloring method identifies independent sets of vertices (those not linked by constraint functions) then solves the constraints associated with each of these sets in a serial fashion using the Gauss-Seidel method. While this method guarantees convergence, it limits vertex/constraint throughput on the GPU and is still inherently serial. The Jacobi method, on the other hand, maximizes parallelism but does not guarantee convergence without the following adjustment to the PBD algorithm: the change in position is computed for each vertex i for all constraints that apply to i in parallel. The final correction applied to i, however, is the average of these adjustments.</p>
</div>
<div class="section" id="geometric-constraints">
<h3>Geometric Constraints<a class="headerlink" href="#geometric-constraints" title="Permalink to this headline">¶</a></h3>
<p>Our cloth model includes four distinct geometric constraints intended to approximate real cloth behavior: distance, isometric bending, long-range attachments, and anchor constraints. We briefly describe each of these here.</p>
<div class="section" id="distance">
<h4>Distance<a class="headerlink" href="#distance" title="Permalink to this headline">¶</a></h4>
<p>The most primitive of geometric constraints, distance-based constraints restore mesh edges that extend or compress relative to their rest lengths.</p>
</div>
<div class="section" id="isometric-bending">
<h4>Isometric Bending<a class="headerlink" href="#isometric-bending" title="Permalink to this headline">¶</a></h4>
<p>The isometric bending constraint restores winged edges to their rest configurations, and is best used with inextensible cloth materials.</p>
</div>
<div class="section" id="anchors">
<h4>Anchors<a class="headerlink" href="#anchors" title="Permalink to this headline">¶</a></h4>
<p>We set the mass of vertices we wish to use as anchor points to infinity. Hence, anchor point weights w = 1 / m are zero, implying that anchor positions are unaffected by constraints.</p>
</div>
<div class="section" id="long-range-attachments">
<h4>Long-Range Attachments<a class="headerlink" href="#long-range-attachments" title="Permalink to this headline">¶</a></h4>
<p>We include this additional distance-based constraint because it helps enforce inextensibility when the cloth model includes anchors.</p>
<img alt="Curtain Effect" src="../_images/default_curtain_70x40_(0.8-0.7-0.3).gif" />
<p><em>A Shower Curtain Using Anchors and Long-Range Attachments</em></p>
</div>
</div>
<div class="section" id="environment-collisions">
<h3>Environment Collisions<a class="headerlink" href="#environment-collisions" title="Permalink to this headline">¶</a></h3>
<p>Environment collisions are currently restricted to SDF-based models for the sphere and plane. The self-collision method described below naturally extends to all point-triangle collisions that might occur in the scene, but SDFs simplify the evaluation of core cloth physics.</p>
<div class="section" id="sphere">
<h4>Sphere<a class="headerlink" href="#sphere" title="Permalink to this headline">¶</a></h4>
<p>Every vertex position is checked to make sure it is outside the radius of the sphere centered at some origin. If not, the vertex is pushed out in the direction parallel to the vector connecting the vertex’s pre-projected position and the sphere’s center.</p>
</div>
<div class="section" id="plane">
<h4>Plane<a class="headerlink" href="#plane" title="Permalink to this headline">¶</a></h4>
<p>Every vertex position is checked to make sure it remains on the same side of the plane it was on in the previous time step. If not, the vertex is pushed back in the direction normal to the plane.</p>
<img alt="Cloth Environment Collisions" src="../_images/cloth_collision.gif" />
<p><em>Plane and Sphere SDF Cloth Collisions</em></p>
</div>
</div>
<div class="section" id="mesh-definition">
<h3>Mesh Definition<a class="headerlink" href="#mesh-definition" title="Permalink to this headline">¶</a></h3>
<p>Mesh behavior is a function of the constraints applied to the mesh, and these in turn are a function of the mesh’s topology. We observe behavioral differences depending on the choice of mesh discretization. We demonstrate two such discretization’s below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><img alt="Center Mesh Topology" class="first last" src="../_images/meshCenterTopology.JPG" />
</td>
<td><img alt="Mesh Default Topology" class="first last" src="../_images/meshDefaultTopology.JPG" />
</td>
</tr>
</tbody>
</table>
<p>On the left, we’ve specified a topology that divides the mesh such that every interior vertex is defined by the joining of four or eight identical triangles that meet isotropically in x and y. This topology guarantees more symmetric behavior. On the other hand, most default meshes will be topologized as on the right. Here, we can see that vertices are defined by the joining of six triangles, but these are biased along a particular diagonal direction. This mesh topology satisfies distance-based constraints more easily, but is biased in its evaluation of bending constraints.</p>
</div>
<div class="section" id="spatial-hashing-with-predictive-constraints-for-self-collisions">
<h3>Spatial Hashing with Predictive Constraints for Self-Collisions<a class="headerlink" href="#spatial-hashing-with-predictive-constraints-for-self-collisions" title="Permalink to this headline">¶</a></h3>
<p>To implement naive self-collision constraint generation, every vertex must be checked against every triangle in the mesh. We accelerate this process by using an adaptive spatial hash grid to bin mesh vertices before constraint projection. We then compute the axis-aligned bounding box encapsulating each triangle and its projected displacement. Then, following Chris Lewin’s [2] prescription for predictive constraints (introduced at GDC 2018, see links below), we generate all self-collision constraints for the cloth. Predictive constraints are computationally expedient and guarantee that cloth vertices never pass through the mesh.</p>
<p>Modified Spatial Hash Grid for Predictive Constraints <a class="footnote-reference" href="#id11" id="id6">[5]</a></p>
<img alt="Modified Spatial Hash Grid" src="../_images/spatial_grid.JPG" />
<img alt="Twist" src="../_images/default_twist_30x30_(0.8-0.7-0.3).gif" />
<p><em>Predictive Constraints Resolve Self-Collisions</em></p>
</div>
</div>
<hr class="docutils" />
<div class="section" id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h2>
<p>This project was written for an engine being developed by one of the authors (see links above). This engine builds to D3D12 and Vulkan for rendering, but for this particular project we restrict ourselves to the D3D12 build. To implement the above methodologies, we include the following shader passes:</p>
<div class="section" id="compute-vertex-projected-positions">
<h3>Compute Vertex Projected Positions<a class="headerlink" href="#compute-vertex-projected-positions" title="Permalink to this headline">¶</a></h3>
<p>After updating particle velocites with any external forces, we update vertex positions: pi = xi + dt * vi in parallel.</p>
</div>
<div class="section" id="binning-initialization">
<h3>Binning Initialization<a class="headerlink" href="#binning-initialization" title="Permalink to this headline">¶</a></h3>
<p>This pass empties each hash grid cell of all previously stored vertices.</p>
</div>
<div class="section" id="vertex-binning">
<h3>Vertex Binning<a class="headerlink" href="#vertex-binning" title="Permalink to this headline">¶</a></h3>
<p>Here, all cloth vertices are binned into their appropriate hash grid cells.</p>
</div>
<div class="section" id="generate-self-collision-constraints">
<h3>Generate Self-Collision Constraints<a class="headerlink" href="#generate-self-collision-constraints" title="Permalink to this headline">¶</a></h3>
<p>We calculate the axis-aligned bounding box encapsulating each triangle and its projected displaced location and check all hash grid cells this box intersects. We then compare the projected positions of vertices binned in these cells with the barycentric-interpolated time-projected position of this vertex’s spatially-projected position on the triangle in consideration. If these predictive measurements indicate a collision is imminent, a predictive constraint is generated using a normal triangle-point collision constraint that is evaluated in the triangle-point pair’s pre-projected frame.</p>
</div>
<div class="section" id="apply-vertex-constraints">
<h3>Apply Vertex Constraints<a class="headerlink" href="#apply-vertex-constraints" title="Permalink to this headline">¶</a></h3>
<p>Here, all constraints are evaluated in parallel, including the self-collision constraints generated in the previous step, distance constraints, long-range attachment constraints, and bending constraints.</p>
</div>
<div class="section" id="apply-deltas">
<h3>Apply Deltas<a class="headerlink" href="#apply-deltas" title="Permalink to this headline">¶</a></h3>
<p>We keep track of the total displacement of each vertex as well as the number of constraints that have affected each vertex. We then average these displacements by dividing by the number of constraints affecting each vertex. This is the essential process in a Jacobi-style solver. Finally, we resolve all SDF environment collisions here.</p>
</div>
<div class="section" id="compute-vertex-positions">
<h3>Compute Vertex Positions<a class="headerlink" href="#compute-vertex-positions" title="Permalink to this headline">¶</a></h3>
<p>Vertex positions and velocities are updated in parallel here as per the PBD algorithm.</p>
<p>NOTE: Apply Vertex Constraints, Apply Deltas, and Compute Vertex Positions are repeated over multiple passes in sequence as per the iterative Jacobi-style parallel solver algorithm.</p>
</div>
<div class="section" id="mesh-normals">
<h3>Mesh Normals<a class="headerlink" href="#mesh-normals" title="Permalink to this headline">¶</a></h3>
<p>This shader computes mesh normals for lighting and normal maps.</p>
</div>
<div class="section" id="shading-pass">
<h3>Shading Pass<a class="headerlink" href="#shading-pass" title="Permalink to this headline">¶</a></h3>
<p>Finally, the mesh is rendered as per the D3D12 API.</p>
</div>
<div class="section" id="frame-timing-breakdown">
<h3>Frame Timing Breakdown<a class="headerlink" href="#frame-timing-breakdown" title="Permalink to this headline">¶</a></h3>
<p>On the left we break down each frame’s total compute time into its constituent components for various square cloth mesh resolutions. On the right we show the percentage of total time (in ms) each compute shader takes for various mesh resolutions in a given frame. We see here that total compute time increases exponentially with mesh resolution, and that the bulk of this time regardless of mesh resolution is spent generating self-collision constraints and applying all constraints to the cloth mesh. The graph on the right demonstrates that self-collision time is minimized for a mesh resolution of 100 x 100. In this case, the time spent generating self-collision constraints is equal to the time spent applying all constraints. As expected, for higher mesh resolutions, self-collision compute time increases faster than all other compute passes. This fact highlights the importance of our spatial hashing acceleration step, as well as the utility of predictive constraints.</p>
<a class="reference external image-reference" href="../_images/compute_time_bar.png"><img alt="Compute Time Bar" src="../_images/compute_time_bar.png" /></a>
<a class="reference external image-reference" href="../_images/percent_breakdown.png"><img alt="Percentage Breakdown" src="../_images/percent_breakdown.png" /></a>
</div>
</div>
<hr class="docutils" />
<div class="section" id="performance">
<h2>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h2>
<p>All timing studies were perfomed using the following software/hardware:</p>
<p>OS: Windows 10<span class="raw-html-m2r"><br></span>
CPU: i7 4790K<span class="raw-html-m2r"><br></span>
GPU: NVIDIA RTX 2080</p>
<p>All compute passes launch with 512 threads per block. We do not use shared memory in any of our compute shaders.</p>
<a class="reference external image-reference" href="../_images/Data.PNG"><img alt="Data" src="../_images/Data.PNG" /></a>
<div class="section" id="cpu-vs-gpu">
<h3>CPU vs GPU<a class="headerlink" href="#cpu-vs-gpu" title="Permalink to this headline">¶</a></h3>
<p>Including basic distance and bending constraints, we managed CPU frame rates upwards of 20 FPS. For a cloth model of equal complexity, we observe frame rates upwards of 400 FPS. We observed a compute-only framerate of 480 FPS for a 200x200 resolution cloth.</p>
</div>
<div class="section" id="total-compute-time-vs-total-constraints-solved">
<h3>Total Compute Time vs Total Constraints Solved<a class="headerlink" href="#total-compute-time-vs-total-constraints-solved" title="Permalink to this headline">¶</a></h3>
<p>As expected, total compute time increases with the total number of constraints solved, which increase with higher mesh resolutions.</p>
<img alt="Total Constraints Time" src="../_images/total_constraints_time.png" />
</div>
<div class="section" id="mesh-resolution-vs-compute-time">
<h3>Mesh Resolution vs Compute Time<a class="headerlink" href="#mesh-resolution-vs-compute-time" title="Permalink to this headline">¶</a></h3>
<p>As noted previously, compute time increases exponentially with increased mesh resolutions (lower is better).</p>
<img alt="Compute Timeline" src="../_images/compute_time_line.png" />
</div>
<div class="section" id="spatial-hash-grid-acceleration">
<h3>Spatial Hash Grid Acceleration<a class="headerlink" href="#spatial-hash-grid-acceleration" title="Permalink to this headline">¶</a></h3>
<p>Here we show compute time acceleration as a function of hash grid resolution. As noted above, self-collisions are the most computationally expensive pass in the compute pipeline. A tuned (optimized resolution) hash grid can speedup the total compute time by as much as 4x the total compute time without one.</p>
<img alt="Grid Resolution Graph" src="../_images/grid_resolutions.png" />
<p><em>All timing values computed for a 200x200 cloth</em></p>
</div>
</div>
<hr class="docutils" />
<div class="section" id="additional-features">
<h2>Additional Features<a class="headerlink" href="#additional-features" title="Permalink to this headline">¶</a></h2>
<div class="section" id="gltf-2-0-mesh-support">
<h3>GLTF 2.0 Mesh Support<a class="headerlink" href="#gltf-2-0-mesh-support" title="Permalink to this headline">¶</a></h3>
<p>Flamenco currently supports GLTF 2.0 mesh loading. However, GLTF meshes do not currently work with cloth self-collisions turned on. We are currently working to enable this feature.</p>
<img alt="Custom GLTF Meshes" src="../_images/custom_cloth_mesh_1.gif" />
<p><em>Flamenco Supports GLTF 2.0 Mesh Loading</em></p>
<p>Our Constraints also work on custom meshes. We also built a vertex aliasing technique that prevents duplicate vertices from being simulated by the core PBD algorithm.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><img alt="GLTF Meshes Stiff" class="first last" src="../_images/custom_cloth_mesh_0_9-0_6.gif" />
</th>
<th class="head"><img alt="GLTF Meshes Relaxed" class="first last" src="../_images/custom_cloth_mesh_0_6-0_1.gif" />
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Distance Constraint = 0.9</td>
<td>Distance Constraint = 0.6</td>
</tr>
<tr class="row-odd"><td>Bending Constraint = 0.6</td>
<td>Bending Constraint = 0.1</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="rendering-pipeline-using-pbr-shading">
<h3>Rendering Pipeline using PBR Shading<a class="headerlink" href="#rendering-pipeline-using-pbr-shading" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Albedo</th>
<th class="head">Normals</th>
<th class="head">Roughness</th>
<th class="head">AO</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="first last reference external image-reference" href="../_images/ClothDiffuse.PNG"><img alt="Diffuse" src="../_images/ClothDiffuse.PNG" /></a>
</td>
<td><a class="first last reference external image-reference" href="../_images/ClothNormal.PNG"><img alt="Normal" src="../_images/ClothNormal.PNG" /></a>
</td>
<td><a class="first last reference external image-reference" href="../_images/ClothRoughness.PNG"><img alt="Roughness" src="../_images/ClothRoughness.PNG" /></a>
</td>
<td><a class="first last reference external image-reference" href="../_images/ClothAO.PNG"><img alt="AO" src="../_images/ClothAO.PNG" /></a>
</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="100%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Final Frame</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><img alt="Final Frame Image" class="first last" src="../_images/ClothAll.PNG" />
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="meme-generator">
<h3>Meme Generator<a class="headerlink" href="#meme-generator" title="Permalink to this headline">¶</a></h3>
<p>We’ve added a toggleable meme generator. Results are shown below.</p>
<img alt="Shehzan Boi" src="../_images/default_shehzan_35x40_(0.8-0.7-0.3).gif" />
</div>
</div>
<hr class="docutils" />
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Jan Bender, Matthias Müller, and Miles Macklin, <a class="reference external" href="http://mmacklin.com/EG2015PBD.pdf">Position-Based Simulation Methods in Computer Graphics</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Chris Lewin, <a class="reference external" href="https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/gdc2018-chrislewin-clothselfcollisionwithpredictivecontacts.pdf">Cloth Self-Collision with Predictive Contacts</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>Marco Fratarcangeli and Fabio Pellacini, <a class="reference external" href="http://publications.lib.chalmers.se/records/fulltext/219708/local_219708.pdf">A GPU-Based Implementation of Position Based Dynamics for Interactive Deformable Bodies</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Matthias Müller, Bruno Heidelberger, Marcus Hennix, and John Ratcliff, <a class="reference external" href="http://matthias-mueller-fischer.ch/publications/posBasedDyn.pdf">Position Based Dynamics</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td>Matthias Teschner, Bruno Heidelberger, Matthias Müller, Danat Pomeranets, and Markus Gross, <a class="reference external" href="http://matthias-mueller-fischer.ch/publications/tetraederCollision.pdf">Optimized Spatial Hashing for Collision Detection of Deformable Objects</a></td></tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="procedural-planet.html" class="btn btn-neutral float-right" title="Procedural Planet" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../projects.html" class="btn btn-neutral" title="Projects" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Vasu Mahesh

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/collapsible-lists\js\CollapsibleLists.compressed.js"></script>
        <script type="text/javascript" src="../_static/collapsible-lists\js\apply-collapsible-lists.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>