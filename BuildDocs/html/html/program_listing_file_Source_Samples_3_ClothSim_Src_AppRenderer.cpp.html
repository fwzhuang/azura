

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File AppRenderer.cpp &mdash; Azura  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists\css\tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="File AppRenderer.Deferred.cpp" href="file_Source_Samples_0_TestZone_Src_AppRenderer.Deferred.cpp.html" />
    <link rel="prev" title="File AppRenderer.cpp" href="file_Source_Samples_3_ClothSim_Src_AppRenderer.cpp.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Azura
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../setting-up.html">Setting Up</a></li>
<li class="toctree-l1"><a class="reference internal" href="../build-instructions.html">Build Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cmake-wrappers.html">CMake Wrappers</a></li>
<li class="toctree-l1"><a class="reference internal" href="apiRoot.html">Azura API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Azura</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="apiRoot.html">Azura API</a> &raquo;</li>
        
          <li><a href="file_Source_Samples_3_ClothSim_Src_AppRenderer.cpp.html">File AppRenderer.cpp</a> &raquo;</li>
        
      <li>Program Listing for File AppRenderer.cpp</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/html/program_listing_file_Source_Samples_3_ClothSim_Src_AppRenderer.cpp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-apprenderer-cpp">
<span id="program-listing-file-source-samples-3-clothsim-src-apprenderer-cpp"></span><h1>Program Listing for File AppRenderer.cpp<a class="headerlink" href="#program-listing-for-file-apprenderer-cpp" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_Source_Samples_3_ClothSim_Src_AppRenderer.cpp.html#file-source-samples-3-clothsim-src-apprenderer-cpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">Source\Samples\3_ClothSim\Src\AppRenderer.cpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#include &quot;ClothSim/AppRenderer.h&quot;
#include &quot;Core/RawStorageFormat.h&quot;
#include &quot;Generic/RenderSystem.h&quot;
#include &quot;Generic/Shader.h&quot;
#include &quot;Memory/MemoryFactory.h&quot;
#include &quot;Memory/MonotonicAllocator.h&quot;
#include &quot;Math/Transform.h&quot;
#include &quot;Math/Icosphere.h&quot;
#include &quot;Math/Plane.h&quot;

namespace Azura {
using namespace Containers;   // NOLINT
using namespace Math;         // NOLINT
using namespace Physics;      // NOLINT
using namespace Physics::PBD; // NOLINT
namespace {
struct LightData {
  Vector4f m_lightPos;
};

constexpr U32 DEFAULT_BLOCK_SIZE_X = 512;
constexpr U32 SOLVER_ITERATIONS = 2;

// Regular
const float DISTANCE_STIFFNESS = 0.8f;
const float BENDING_STIFFNESS = 0.7f;
const float LONG_RANGE_STIFFNESS = 0.3f;

const Vector3f TEST_SPHERE_CENTER = Vector3f(0, -5, 0);
const Vector3f TEST_PLANE_CENTER = Vector3f(0, -8.01f, 0);
constexpr float TEST_SPHERE_RADIUS = 2.9f;
constexpr float CLOTH_SPAN_X = 5;
constexpr float CLOTH_SPAN_Y = 5;
constexpr float CLOTH_WORLD_HEIGHT = 5.0f;
constexpr U32 CLOTH_DIV_X = 30;
constexpr U32 CLOTH_DIV_Y = 30;
constexpr U32 TEXTURE_MEMORY = 0x4000000; // 64 MB
constexpr U32 ANCHOR_IDX_1 = 0;
constexpr U32 ANCHOR_IDX_2 = (CLOTH_DIV_Y * (CLOTH_DIV_X + 1));
constexpr U32 ANCHOR_IDX_3 = CLOTH_DIV_Y;
constexpr U32 ANCHOR_IDX_4 = ANCHOR_IDX_2 + CLOTH_DIV_Y;

constexpr U32 CLOTH_UV_SCALE_X = 2;
constexpr U32 CLOTH_UV_SCALE_Y = 2;

constexpr U32 MAX_GRID_RESOLUTION_X = 20;
constexpr U32 MAX_GRID_RESOLUTION_Y = 20;
constexpr U32 MAX_GRID_RESOLUTION_Z = 20;
constexpr U32 MAX_VERTICES_PER_BIN = 32;
constexpr U32 MAX_SELF_POINT_TRIANGLE_COLLISIONS = 2048;
constexpr U32 MAX_ANCHOR_POINTS = 128;
constexpr U32 CURTAIN_ANCHORS = 6;
constexpr float BASE_CURTAIN_STEP_SIZE = 5.0f;

constexpr bool RENDER_FLOOR_PLANE = true;
constexpr bool RENDER_SPHERE = false;

constexpr bool USE_MESH = false;
constexpr bool USE_CURTAIN = false;
constexpr bool SHEHZAN = false;

constexpr bool SCENE_ANGULAR_VELOCITY = false;
const Vector3f ANGULAR_VELOCITY = Vector3f(0, 4.5f * Math::PI, 0);
const Vector3f CLOTH_ORIGIN = Vector3f(0, CLOTH_WORLD_HEIGHT, 0);

constexpr bool SCENE_TWIST = false;

} // namespace

AppRenderer::AppRenderer()
  : log_AppRenderer(Log(&quot;AppRenderer&quot;)),
    m_mainBuffer(0xC00&#39;0000),
    m_mainAllocator(m_mainBuffer, 0x400&#39;0000),
    m_localAllocator(m_mainBuffer, 0x400&#39;0000),
    m_drawableAllocator(m_mainBuffer, 0x400&#39;0000),
    m_camera(1280, 720),
    m_curtainTransforms(ContainerExtent{CURTAIN_ANCHORS}, m_mainAllocator),
    m_clothPlane(ClothTriangulation::Regular, Vector2f(-CLOTH_SPAN_X, -CLOTH_SPAN_Y), Vector2f(CLOTH_SPAN_X, CLOTH_SPAN_Y), CLOTH_WORLD_HEIGHT,
                 Vector2u(CLOTH_DIV_X, CLOTH_DIV_Y), Vector2u(CLOTH_UV_SCALE_X, CLOTH_UV_SCALE_Y), m_localAllocator),
    m_clothMesh(&quot;CustomCloth2&quot;, AssetLocation::Meshes, m_localAllocator, log_AppRenderer) {
}

void AppRenderer::Initialize() {
  LOG_INF(log_AppRenderer, LOG_LEVEL, &quot;Starting Init of AppRenderer&quot;);

  if (USE_MESH)
  {
    p_activeMesh = &amp;m_clothMesh;
  }
  else
  {
    p_activeMesh = &amp;m_clothPlane;
  }

  m_clothTransform.SetForwardKey(KeyboardKey::Up);
  m_clothTransform.SetBackwardKey(KeyboardKey::Down);
  m_clothTransform.SetLeftKey(KeyboardKey::Left);
  m_clothTransform.SetRightKey(KeyboardKey::Right);
  m_clothTransform.SetStepSize(8.0f);

  if (USE_CURTAIN)
  {
    for (U32 idx = 0; idx &lt; CURTAIN_ANCHORS; idx++)
    {
      m_curtainTransforms[idx].SetForwardKey(KeyboardKey::Up);
      m_curtainTransforms[idx].SetBackwardKey(KeyboardKey::Down);
      m_curtainTransforms[idx].SetLeftKey(KeyboardKey::Left);
      m_curtainTransforms[idx].SetRightKey(KeyboardKey::Right);
      m_curtainTransforms[idx].SetStepSize((float(idx) / (CURTAIN_ANCHORS - 1)) * BASE_CURTAIN_STEP_SIZE);
    }
  }

  HEAP_ALLOCATOR(Temporary, Memory::MonotonicAllocator, 0x400&#39;0000);
  m_window = RenderSystem::CreateApplicationWindow(&quot;PBD Cloth Simulation&quot;, 1280, 720);

  m_window-&gt;SetUpdateRate(UpdateRate::Rate120);

  m_window-&gt;SetUpdateCallback([this](float deltaTime)
  {
    WindowUpdate(deltaTime);
  });

  m_window-&gt;SetKeyEventCallback([this](KeyEvent evt)
  {
    m_camera.OnKeyEvent(evt);
    m_clothTransform.OnKeyEvent(evt);

    if (evt.m_internalType == KeyEventType::KeyPress &amp;&amp; evt.m_key == KeyboardKey::U) {
      m_rotateFactor = 1;
    }
    else if (evt.m_internalType == KeyEventType::KeyPress &amp;&amp; evt.m_key == KeyboardKey::I) {
      m_rotateFactor = -1;
    }
    else if (evt.m_internalType == KeyEventType::KeyRelease &amp;&amp; evt.m_key == KeyboardKey::U) {
      m_rotateFactor = 0;
    }
    else if (evt.m_internalType == KeyEventType::KeyRelease &amp;&amp; evt.m_key == KeyboardKey::I) {
      m_rotateFactor = 0;
    }

    if (USE_CURTAIN)
    {
      for (U32 idx = 0; idx &lt; CURTAIN_ANCHORS; idx++)
      {
        m_curtainTransforms[idx].OnKeyEvent(evt);
      }
    }
  });

  m_window-&gt;SetMouseEventCallback([this](MouseEvent evt)
  {
    UNUSED(evt);
    // Disable as it has bugs
    // m_camera.OnMouseEvent(e);
  });

  m_camera.SetZoom(35);
  m_camera.RotateAboutRight(10);
  m_camera.SetStepSize(30.0f);

  VERIFY_TRUE(log_AppRenderer, m_window-&gt;Initialize(), &quot;Cannot Initialize Window&quot;);

  ApplicationInfo appInfo;
  appInfo.m_name = &quot;PBD Cloth Simulation&quot;;
  appInfo.m_version = Version(1, 0, 0);

  DeviceRequirements requirements;
  requirements.m_discreteGPU = true;
  requirements.m_float64 = false;
  requirements.m_int64 = false;
  requirements.m_transferQueue = false;

  m_camera.Recompute();

  m_clothUBO = {};
  m_clothUBO.m_model = m_clothTransform.GetTransform();
  m_clothUBO.m_view = m_camera.GetViewMatrix();
  m_clothUBO.m_viewProj = m_camera.GetViewProjMatrix();
  m_clothUBO.m_invViewProj = m_camera.GetInvViewProjMatrix();
  m_clothUBO.m_invProj = m_camera.GetProjMatrix().Inverse();
  m_clothUBO.m_modelInvTranspose = m_clothUBO.m_model.Inverse().Transpose();

  m_sphereUBO = {};
  m_sphereUBO.m_model = Matrix4f::FromTranslationVector(TEST_SPHERE_CENTER) * Matrix4f::FromScaleVector(Vector3f(TEST_SPHERE_RADIUS, TEST_SPHERE_RADIUS, TEST_SPHERE_RADIUS));
  m_sphereUBO.m_viewProj = m_camera.GetViewProjMatrix();
  m_sphereUBO.m_view = m_camera.GetViewMatrix();
  m_sphereUBO.m_invViewProj = m_camera.GetInvViewProjMatrix();
  m_sphereUBO.m_invProj = m_camera.GetProjMatrix().Inverse();
  m_sphereUBO.m_modelInvTranspose = m_sphereUBO.m_model.Inverse().Transpose();

  m_planeUBO = {};
  m_planeUBO.m_model = Matrix4f::FromTranslationVector(TEST_PLANE_CENTER);
  m_planeUBO.m_viewProj = m_camera.GetViewProjMatrix();
  m_planeUBO.m_view = m_camera.GetViewMatrix();
  m_planeUBO.m_invViewProj = m_camera.GetInvViewProjMatrix();
  m_planeUBO.m_invProj = m_camera.GetProjMatrix().Inverse();
  m_planeUBO.m_modelInvTranspose = m_planeUBO.m_model.Inverse().Transpose();

  m_shehzanUBO = {};
  m_shehzanUBO.m_model = Matrix4f::FromTranslationVector(Vector3f(0, 3, -8)) * Matrix4f::FromRotationMatrix(Matrix4f::RotationX(-Math::PI_OVER2));
  m_shehzanUBO.m_viewProj = m_camera.GetViewProjMatrix();
  m_shehzanUBO.m_view = m_camera.GetViewMatrix();
  m_shehzanUBO.m_invViewProj = m_camera.GetInvViewProjMatrix();
  m_shehzanUBO.m_invProj = m_camera.GetProjMatrix().Inverse();
  m_shehzanUBO.m_modelInvTranspose = m_planeUBO.m_model.Inverse().Transpose();

  LightData lightData = {};
  lightData.m_lightPos = Vector4f(0.0f, 15.0f, 20.0f, 1.0f);

  // TODO(vasumahesh1):[Q]:Allocator?
  const ApplicationRequirements applicationRequirements = {};

  TextureRequirements textureRequirements = {};
  textureRequirements.m_maxCount = 15;
  textureRequirements.m_poolSize = TEXTURE_MEMORY;

  DescriptorRequirements descriptorRequirements = DescriptorRequirements(10, 6, allocatorTemporary);
  // SET 0
  const U32 UBO_SLOT = descriptorRequirements.AddDescriptor({
    DescriptorType::UniformBuffer, ShaderStage::Vertex
    });
  const U32 LIGHT_SLOT = descriptorRequirements.AddDescriptor({
    DescriptorType::UniformBuffer, ShaderStage::Vertex
    });

  const U32 SAMPLER_SLOT = descriptorRequirements.AddDescriptor({ DescriptorType::Sampler, ShaderStage::Pixel });
  const U32 TEXTURE_SLOT = descriptorRequirements.AddDescriptor({ DescriptorType::SampledImage, ShaderStage::Pixel });
  const U32 NORMALS_SLOT = descriptorRequirements.AddDescriptor({ DescriptorType::SampledImage, ShaderStage::Pixel });
  const U32 ROUGHNESS_SLOT = descriptorRequirements.AddDescriptor({ DescriptorType::SampledImage, ShaderStage::Pixel });
  const U32 AO_SLOT = descriptorRequirements.AddDescriptor({ DescriptorType::SampledImage, ShaderStage::Pixel });

  // SET 0 Compute
  m_computePass.m_computeUBOSlot = descriptorRequirements.AddDescriptor({
    DescriptorType::UniformBuffer, ShaderStage::Compute
    });

  // SET 0 Normal Compute
  m_normalsPass.m_uboSlot = descriptorRequirements.AddDescriptor({
    DescriptorType::UniformBuffer, ShaderStage::Compute
    });

  const U32 UBO_SET = descriptorRequirements.AddSet({ UBO_SLOT });
  const U32 LIGHT_SET = descriptorRequirements.AddSet({ LIGHT_SLOT });
  const U32 SAMPLER_SET = descriptorRequirements.AddSet({ SAMPLER_SLOT });
  const U32 TEXTURE_SET = descriptorRequirements.AddSet({ TEXTURE_SLOT, NORMALS_SLOT, ROUGHNESS_SLOT, AO_SLOT });

  const U32 COMPUTE_UBO_SET = descriptorRequirements.AddSet({ m_computePass.m_computeUBOSlot });
  const U32 COMPUTE_NORMALS_UBO_SET = descriptorRequirements.AddSet({ m_normalsPass.m_uboSlot });

  ShaderRequirements shaderRequirements = ShaderRequirements(15, allocatorTemporary);
  // const U32 MAIN_COMPUTE_SHADER_ID           = shaderRequirements.AddShader({
  //   ShaderStage::Compute, &quot;SolvingPass_Cloth.cs&quot;, AssetLocation::Shaders
  // });

  const U32 COMPUTE_1_PBD = shaderRequirements.AddShader({
      ShaderStage::Compute, &quot;SolvingPass_Cloth_ComputeProjectedPositions.cs&quot;, AssetLocation::Shaders
    });

  const U32 COMPUTE_SELF_COLLSIONS = shaderRequirements.AddShader({
      ShaderStage::Compute, &quot;SolvingPass_Cloth_GenerateSelfCollisions.cs&quot;, AssetLocation::Shaders
    });

  const U32 COMPUTE_2_BINNING_INIT = shaderRequirements.AddShader({
      ShaderStage::Compute, &quot;SolvingPass_Cloth_BinningInit.cs&quot;, AssetLocation::Shaders
    });

  const U32 COMPUTE_2_BINNING = shaderRequirements.AddShader({
      ShaderStage::Compute, &quot;SolvingPass_Cloth_Binning.cs&quot;, AssetLocation::Shaders
    });

  const U32 COMPUTE_2_PBD = shaderRequirements.AddShader({
    ShaderStage::Compute, &quot;SolvingPass_Cloth_ApplyConstraints.cs&quot;, AssetLocation::Shaders
    });

  const U32 COMPUTE_3_PBD = shaderRequirements.AddShader({
    ShaderStage::Compute, &quot;SolvingPass_Cloth_ApplyDelta.cs&quot;, AssetLocation::Shaders
    });

  const U32 COMPUTE_4_PBD = shaderRequirements.AddShader({
    ShaderStage::Compute, &quot;SolvingPass_Cloth_ComputePositions.cs&quot;, AssetLocation::Shaders
    });

  const U32 VERTEX_SHADER_ID = shaderRequirements.AddShader({
    ShaderStage::Vertex, &quot;ShadingPass_Cloth.vs&quot;, AssetLocation::Shaders
    });
  const U32 PIXEL_SHADER_ID = shaderRequirements.AddShader({
    ShaderStage::Pixel, &quot;ShadingPass_Cloth.ps&quot;, AssetLocation::Shaders
    });

  // NOLINTNEXTLINE
  const U32 SPHERE_VERTEX_SHADER_ID = shaderRequirements.AddShader({
    ShaderStage::Vertex, &quot;ShadingPass_Sphere.vs&quot;, AssetLocation::Shaders
    });

  // NOLINTNEXTLINE
  const U32 SPHERE_PIXEL_SHADER_ID = shaderRequirements.AddShader({
    ShaderStage::Pixel, &quot;ShadingPass_Sphere.ps&quot;, AssetLocation::Shaders
    });

  // NOLINTNEXTLINE
  const U32 PLANE_VERTEX_SHADER_ID = shaderRequirements.AddShader({
    ShaderStage::Vertex, &quot;ShadingPass_Plane.vs&quot;, AssetLocation::Shaders
    });

  // NOLINTNEXTLINE
  const U32 PLANE_PIXEL_SHADER_ID = shaderRequirements.AddShader({
    ShaderStage::Pixel, &quot;ShadingPass_Plane.ps&quot;, AssetLocation::Shaders
    });

  // NOLINTNEXTLINE
  const U32 SHEHZAN_VERTEX_SHADER_ID = shaderRequirements.AddShader({
    ShaderStage::Vertex, &quot;ShadingPass_Shehzan.vs&quot;, AssetLocation::Shaders
    });

  // NOLINTNEXTLINE
  const U32 SHEHZAN_PIXEL_SHADER_ID = shaderRequirements.AddShader({
    ShaderStage::Pixel, &quot;ShadingPass_Shehzan.ps&quot;, AssetLocation::Shaders
    });

  const U32 COMPUTE_NORMALS_SHADER_ID = shaderRequirements.AddShader({
    ShaderStage::Compute, &quot;NormalsPass_Normalize.cs&quot;, AssetLocation::Shaders
    });

  std::vector&lt;int&gt; vertexModelMatrixIdBuffer = std::vector&lt;int&gt;(p_activeMesh-&gt;GetVertexCount(), -1);

  if (USE_MESH)
  {
    const auto&amp; aliases = static_cast&lt;ClothMesh*&gt;(p_activeMesh)-&gt;GetVertexAliases(); // NOLINT
    for (U32 idx = 4095; idx &lt; 4159u; ++idx) {
      p_activeMesh-&gt;SetAnchorOnIndex(idx);

      U32 correctId = aliases[idx] != -1 ? aliases[idx] : idx;
      vertexModelMatrixIdBuffer[correctId] = 0;
    }

    // p_activeMesh-&gt;SetAnchorOnIndex(263);
  }
  else
  {
    if (USE_CURTAIN)
    {
      const U32 stepSize = U32((CLOTH_DIV_X + 1) / (CURTAIN_ANCHORS - 1)) * (CLOTH_DIV_Y + 1);
      for (U32 idx = 0; idx &lt; CURTAIN_ANCHORS; idx++)
      {
        const U32 anchorIdx = idx * stepSize;
        p_activeMesh-&gt;SetAnchorOnIndex(anchorIdx);
        vertexModelMatrixIdBuffer[anchorIdx] = idx;
      }
    }
    else
    {
      if (!SCENE_ANGULAR_VELOCITY &amp;&amp; !SCENE_TWIST) {
        p_activeMesh-&gt;SetAnchorOnIndex(ANCHOR_IDX_1);
        p_activeMesh-&gt;SetAnchorOnIndex(ANCHOR_IDX_2);

        vertexModelMatrixIdBuffer[ANCHOR_IDX_1] = 0;
        vertexModelMatrixIdBuffer[ANCHOR_IDX_2] = 1;
      }

      if (SCENE_TWIST)
      {
        p_activeMesh-&gt;SetAnchorOnIndex(ANCHOR_IDX_1);
        p_activeMesh-&gt;SetAnchorOnIndex(ANCHOR_IDX_2);
        p_activeMesh-&gt;SetAnchorOnIndex(ANCHOR_IDX_3);
        p_activeMesh-&gt;SetAnchorOnIndex(ANCHOR_IDX_4);

        vertexModelMatrixIdBuffer[ANCHOR_IDX_1] = 0;
        vertexModelMatrixIdBuffer[ANCHOR_IDX_2] = 0;
        vertexModelMatrixIdBuffer[ANCHOR_IDX_3] = 1;
        vertexModelMatrixIdBuffer[ANCHOR_IDX_4] = 1;
      }
    }
  }

  const auto solvingView = p_activeMesh-&gt;GetPBDSolvingView(m_localAllocator);
  const auto&amp; clothDistanceConstraints = solvingView.GetDistanceConstraints();
  const auto&amp; clothLongRangeConstraints = solvingView.GetLongRangeConstraints();
  const auto&amp; clothBendingConstraints = solvingView.GetBendingConstraints();
  const auto&amp; clothDataSet = solvingView.GetDataSet();

  m_normalUBO = {};
  m_normalUBO.m_numTriangles = p_activeMesh-&gt;GetIndexCount() / 3;
  m_normalUBO.m_numVertices = p_activeMesh-&gt;GetVertexCount();

  RenderPassRequirements renderPassRequirements = RenderPassRequirements(0, 15 + (SOLVER_ITERATIONS * 2), 30, allocatorTemporary);
  renderPassRequirements.m_maxPools = 15 + (SOLVER_ITERATIONS * 2);

  const U32 COMPUTE_VERTEX_BUFFER = renderPassRequirements.AddBuffer({
    U32(sizeof(Vector3f)) * U32(p_activeMesh-&gt;GetVertexCount()), U32(sizeof(Vector3f))
    });

  const U32 COMPUTE_PROJECTION_BUFFER = renderPassRequirements.AddBuffer({
    U32(sizeof(Vector3f)) * U32(p_activeMesh-&gt;GetVertexCount()), U32(sizeof(Vector3f))
    });

  const U32 COMPUTE_VERTEX_VELOCITY = renderPassRequirements.AddBuffer({
    U32(sizeof(Vector3f)) * U32(p_activeMesh-&gt;GetVertexCount()), U32(sizeof(Vector3f))
    });

  const U32 COMPUTE_VERTEX_INV_MASS = renderPassRequirements.AddBuffer({
    U32(sizeof(float)) * U32(p_activeMesh-&gt;GetVertexCount()), U32(sizeof(float))
    });

  const U32 COMPUTE_VERTEX_CONSTRAINT_COUNT = renderPassRequirements.AddBuffer({
    U32(sizeof(U32)) * U32(p_activeMesh-&gt;GetVertexCount()), U32(sizeof(U32))
    });

  const U32 COMPUTE_VERTEX_DELTAX = renderPassRequirements.AddBuffer({
    U32(sizeof(U32)) * U32(p_activeMesh-&gt;GetVertexCount()), U32(sizeof(U32))
    });

  const U32 COMPUTE_VERTEX_DELTAY = renderPassRequirements.AddBuffer({
    U32(sizeof(U32)) * U32(p_activeMesh-&gt;GetVertexCount()), U32(sizeof(U32))
    });

  const U32 COMPUTE_VERTEX_DELTAZ = renderPassRequirements.AddBuffer({
    U32(sizeof(U32)) * U32(p_activeMesh-&gt;GetVertexCount()), U32(sizeof(U32))
    });

  const U32 DISTANCE_CONSTRAINTS_BUFFER = renderPassRequirements.AddBuffer({
    U32(sizeof(DistanceConstraint)) * U32(clothDistanceConstraints.GetSize()), U32(sizeof(DistanceConstraint))
    });

  const U32 LONG_RANGE_CONSTRAINTS_BUFFER = renderPassRequirements.AddBuffer({
    U32(sizeof(LongRangeConstraint)) * U32(clothLongRangeConstraints.GetSize()), U32(sizeof(LongRangeConstraint))
    });

  const U32 BEND_CONSTRAINTS_BUFFER = renderPassRequirements.AddBuffer({
    U32(sizeof(BendingConstraint)) * U32(clothBendingConstraints.GetSize()), U32(sizeof(BendingConstraint))
    });

  const U32 COMPUTE_INDEX_BUFFER = renderPassRequirements.AddBuffer({
    U32(sizeof(U32)) * U32(p_activeMesh-&gt;GetIndexCount()), U32(sizeof(U32))
    });

  const U32 COMPUTE_VERTEX_TANX = renderPassRequirements.AddBuffer({
    U32(sizeof(U32)) * U32(p_activeMesh-&gt;GetVertexCount()), U32(sizeof(U32))
    });

  const U32 COMPUTE_VERTEX_TANY = renderPassRequirements.AddBuffer({
    U32(sizeof(U32)) * U32(p_activeMesh-&gt;GetVertexCount()), U32(sizeof(U32))
    });

  const U32 COMPUTE_VERTEX_TANZ = renderPassRequirements.AddBuffer({
    U32(sizeof(U32)) * U32(p_activeMesh-&gt;GetVertexCount()), U32(sizeof(U32))
    });

  const U32 COMPUTE_VERTEX_ALIAS_BUFFER = renderPassRequirements.AddBuffer({
    U32(sizeof(int)) * U32(p_activeMesh-&gt;GetVertexCount()), U32(sizeof(int))
    });

  const U32 COMPUTE_CLOTH_PROPERTIES = renderPassRequirements.AddBuffer({
    U32(sizeof(ClothComputeProperties)), U32(sizeof(ClothComputeProperties))
    });

  const U32 COMPUTE_GRID_COUNT = renderPassRequirements.AddBuffer({
    U32(sizeof(U32) * MAX_GRID_RESOLUTION_X * MAX_GRID_RESOLUTION_Y * MAX_GRID_RESOLUTION_Z), U32(sizeof(U32))
    });

  const U32 COMPUTE_GRID_VERTICES = renderPassRequirements.AddBuffer({
    U32(sizeof(U32) * MAX_VERTICES_PER_BIN * MAX_GRID_RESOLUTION_X * MAX_GRID_RESOLUTION_Y * MAX_GRID_RESOLUTION_Z), U32(sizeof(U32))
    });

  const U32 COMPUTE_POINT_TRI_SELF_COLLISIONS_CONSTRAINT = renderPassRequirements.AddBuffer({
    U32(sizeof(SelfCollisionConstraint) * MAX_SELF_POINT_TRIANGLE_COLLISIONS), U32(sizeof(SelfCollisionConstraint))
    });

  const U32 COMPUTE_VERTEX_MODEL_MATRICES = renderPassRequirements.AddBuffer({
    U32(sizeof(int) * U32(p_activeMesh-&gt;GetVertexCount())), U32(sizeof(int))
    });

  m_computePass.m_pass1 = renderPassRequirements.AddPass({
    PipelinePassCreateInfo::Shaders{},
    PipelinePassCreateInfo::InputTargets{},
    PipelinePassCreateInfo::InputBuffers{
      {DISTANCE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {BEND_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {LONG_RANGE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_INV_MASS, ShaderStage::Compute}, {COMPUTE_VERTEX_ALIAS_BUFFER, ShaderStage::Compute}, {COMPUTE_INDEX_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_MODEL_MATRICES, ShaderStage::Compute}
    },
    PipelinePassCreateInfo::OutputTargets{},
    PipelinePassCreateInfo::OutputBuffers{
      COMPUTE_CLOTH_PROPERTIES, COMPUTE_GRID_COUNT, COMPUTE_GRID_VERTICES, COMPUTE_POINT_TRI_SELF_COLLISIONS_CONSTRAINT, COMPUTE_VERTEX_BUFFER, COMPUTE_PROJECTION_BUFFER, COMPUTE_VERTEX_VELOCITY, COMPUTE_VERTEX_CONSTRAINT_COUNT,
      COMPUTE_VERTEX_DELTAX, COMPUTE_VERTEX_DELTAY, COMPUTE_VERTEX_DELTAZ
    },
    PipelinePassCreateInfo::DescriptorSets{COMPUTE_UBO_SET},
    ClearData{{0.0f, 0.0f, 0.0f, 1.0f}, 1.0f, 0},
    BlendState{},
    RenderPassType::Compute
    });

  m_computePass.m_passInitialize = renderPassRequirements.AddPass({
    PipelinePassCreateInfo::Shaders{},
    PipelinePassCreateInfo::InputTargets{},
    PipelinePassCreateInfo::InputBuffers{
      {DISTANCE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {BEND_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {LONG_RANGE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_INV_MASS, ShaderStage::Compute}, {COMPUTE_VERTEX_ALIAS_BUFFER, ShaderStage::Compute}, {COMPUTE_INDEX_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_MODEL_MATRICES, ShaderStage::Compute}
    },
    PipelinePassCreateInfo::OutputTargets{},
    PipelinePassCreateInfo::OutputBuffers{
      COMPUTE_CLOTH_PROPERTIES, COMPUTE_GRID_COUNT, COMPUTE_GRID_VERTICES, COMPUTE_POINT_TRI_SELF_COLLISIONS_CONSTRAINT, COMPUTE_VERTEX_BUFFER, COMPUTE_PROJECTION_BUFFER, COMPUTE_VERTEX_VELOCITY, COMPUTE_VERTEX_CONSTRAINT_COUNT,
      COMPUTE_VERTEX_DELTAX, COMPUTE_VERTEX_DELTAY, COMPUTE_VERTEX_DELTAZ
    },
    PipelinePassCreateInfo::DescriptorSets{COMPUTE_UBO_SET},
    ClearData{{0.0f, 0.0f, 0.0f, 1.0f}, 1.0f, 0},
    BlendState{},
    RenderPassType::Compute
    });

  m_computePass.m_passBinning = renderPassRequirements.AddPass({
    PipelinePassCreateInfo::Shaders{},
    PipelinePassCreateInfo::InputTargets{},
    PipelinePassCreateInfo::InputBuffers{
      {DISTANCE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {BEND_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {LONG_RANGE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_INV_MASS, ShaderStage::Compute}, {COMPUTE_VERTEX_ALIAS_BUFFER, ShaderStage::Compute}, {COMPUTE_INDEX_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_MODEL_MATRICES, ShaderStage::Compute}
    },
    PipelinePassCreateInfo::OutputTargets{},
    PipelinePassCreateInfo::OutputBuffers{
      COMPUTE_CLOTH_PROPERTIES, COMPUTE_GRID_COUNT, COMPUTE_GRID_VERTICES, COMPUTE_POINT_TRI_SELF_COLLISIONS_CONSTRAINT, COMPUTE_VERTEX_BUFFER, COMPUTE_PROJECTION_BUFFER, COMPUTE_VERTEX_VELOCITY, COMPUTE_VERTEX_CONSTRAINT_COUNT,
      COMPUTE_VERTEX_DELTAX, COMPUTE_VERTEX_DELTAY, COMPUTE_VERTEX_DELTAZ
    },
    PipelinePassCreateInfo::DescriptorSets{COMPUTE_UBO_SET},
    ClearData{{0.0f, 0.0f, 0.0f, 1.0f}, 1.0f, 0},
    BlendState{},
    RenderPassType::Compute
    });

  m_computePass.m_passSelfCollisions = renderPassRequirements.AddPass({
    PipelinePassCreateInfo::Shaders{},
    PipelinePassCreateInfo::InputTargets{},
    PipelinePassCreateInfo::InputBuffers{
      {DISTANCE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {BEND_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {LONG_RANGE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_INV_MASS, ShaderStage::Compute}, {COMPUTE_VERTEX_ALIAS_BUFFER, ShaderStage::Compute}, {COMPUTE_INDEX_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_MODEL_MATRICES, ShaderStage::Compute}
    },
    PipelinePassCreateInfo::OutputTargets{},
    PipelinePassCreateInfo::OutputBuffers{
      COMPUTE_CLOTH_PROPERTIES, COMPUTE_GRID_COUNT, COMPUTE_GRID_VERTICES, COMPUTE_POINT_TRI_SELF_COLLISIONS_CONSTRAINT, COMPUTE_VERTEX_BUFFER, COMPUTE_PROJECTION_BUFFER, COMPUTE_VERTEX_VELOCITY, COMPUTE_VERTEX_CONSTRAINT_COUNT,
      COMPUTE_VERTEX_DELTAX, COMPUTE_VERTEX_DELTAY, COMPUTE_VERTEX_DELTAZ
    },
    PipelinePassCreateInfo::DescriptorSets{COMPUTE_UBO_SET},
    ClearData{{0.0f, 0.0f, 0.0f, 1.0f}, 1.0f, 0},
    BlendState{},
    RenderPassType::Compute
    });

  m_computePass.m_passItr1.reserve(SOLVER_ITERATIONS);
  m_computePass.m_passItr2.reserve(SOLVER_ITERATIONS);
  m_iterativePools.reserve(SOLVER_ITERATIONS);

  for (U32 idx = 0; idx &lt; SOLVER_ITERATIONS; ++idx) {
    m_computePass.m_passItr1.push_back(renderPassRequirements.AddPass({
      PipelinePassCreateInfo::Shaders{},
      PipelinePassCreateInfo::InputTargets{},
      PipelinePassCreateInfo::InputBuffers{
        {DISTANCE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {BEND_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {LONG_RANGE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_INV_MASS, ShaderStage::Compute}, {COMPUTE_VERTEX_ALIAS_BUFFER, ShaderStage::Compute}, {COMPUTE_INDEX_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_MODEL_MATRICES, ShaderStage::Compute}
      },
      PipelinePassCreateInfo::OutputTargets{},
      PipelinePassCreateInfo::OutputBuffers{
        COMPUTE_CLOTH_PROPERTIES, COMPUTE_GRID_COUNT, COMPUTE_GRID_VERTICES, COMPUTE_POINT_TRI_SELF_COLLISIONS_CONSTRAINT, COMPUTE_VERTEX_BUFFER, COMPUTE_PROJECTION_BUFFER, COMPUTE_VERTEX_VELOCITY, COMPUTE_VERTEX_CONSTRAINT_COUNT,
        COMPUTE_VERTEX_DELTAX, COMPUTE_VERTEX_DELTAY, COMPUTE_VERTEX_DELTAZ
      },
      PipelinePassCreateInfo::DescriptorSets{COMPUTE_UBO_SET},
      ClearData{{0.0f, 0.0f, 0.0f, 1.0f}, 1.0f, 0},
      BlendState{},
      RenderPassType::Compute
      }));

    m_computePass.m_passItr2.push_back(renderPassRequirements.AddPass({
      PipelinePassCreateInfo::Shaders{},
      PipelinePassCreateInfo::InputTargets{},
      PipelinePassCreateInfo::InputBuffers{
        {DISTANCE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {BEND_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {LONG_RANGE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_INV_MASS, ShaderStage::Compute}, {COMPUTE_VERTEX_ALIAS_BUFFER, ShaderStage::Compute}, {COMPUTE_INDEX_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_MODEL_MATRICES, ShaderStage::Compute}
      },
      PipelinePassCreateInfo::OutputTargets{},
      PipelinePassCreateInfo::OutputBuffers{
        COMPUTE_CLOTH_PROPERTIES, COMPUTE_GRID_COUNT, COMPUTE_GRID_VERTICES, COMPUTE_POINT_TRI_SELF_COLLISIONS_CONSTRAINT, COMPUTE_VERTEX_BUFFER, COMPUTE_PROJECTION_BUFFER, COMPUTE_VERTEX_VELOCITY, COMPUTE_VERTEX_CONSTRAINT_COUNT,
        COMPUTE_VERTEX_DELTAX, COMPUTE_VERTEX_DELTAY, COMPUTE_VERTEX_DELTAZ
      },
      PipelinePassCreateInfo::DescriptorSets{COMPUTE_UBO_SET},
      ClearData{{0.0f, 0.0f, 0.0f, 1.0f}, 1.0f, 0},
      BlendState{},
      RenderPassType::Compute
      }));
  }

  m_computePass.m_pass4 = renderPassRequirements.AddPass({
    PipelinePassCreateInfo::Shaders{},
    PipelinePassCreateInfo::InputTargets{},
    PipelinePassCreateInfo::InputBuffers{
      {DISTANCE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {BEND_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {LONG_RANGE_CONSTRAINTS_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_INV_MASS, ShaderStage::Compute}, {COMPUTE_VERTEX_ALIAS_BUFFER, ShaderStage::Compute}, {COMPUTE_INDEX_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_MODEL_MATRICES, ShaderStage::Compute}
    },
    PipelinePassCreateInfo::OutputTargets{},
    PipelinePassCreateInfo::OutputBuffers{
      COMPUTE_CLOTH_PROPERTIES, COMPUTE_GRID_COUNT, COMPUTE_GRID_VERTICES, COMPUTE_POINT_TRI_SELF_COLLISIONS_CONSTRAINT, COMPUTE_VERTEX_BUFFER, COMPUTE_PROJECTION_BUFFER, COMPUTE_VERTEX_VELOCITY, COMPUTE_VERTEX_CONSTRAINT_COUNT,
      COMPUTE_VERTEX_DELTAX, COMPUTE_VERTEX_DELTAY, COMPUTE_VERTEX_DELTAZ, COMPUTE_VERTEX_TANX, COMPUTE_VERTEX_TANY, COMPUTE_VERTEX_TANZ
    },
    PipelinePassCreateInfo::DescriptorSets{COMPUTE_UBO_SET},
    ClearData{{0.0f, 0.0f, 0.0f, 1.0f}, 1.0f, 0},
    BlendState{},
    RenderPassType::Compute
    });

  m_normalsPass.m_passId = renderPassRequirements.AddPass({
    PipelinePassCreateInfo::Shaders{COMPUTE_NORMALS_SHADER_ID},
    PipelinePassCreateInfo::InputTargets{},
    PipelinePassCreateInfo::InputBuffers{
      {COMPUTE_INDEX_BUFFER, ShaderStage::Compute}, {COMPUTE_VERTEX_BUFFER, ShaderStage::Compute}
    },
    PipelinePassCreateInfo::OutputTargets{},
    PipelinePassCreateInfo::OutputBuffers{
      COMPUTE_VERTEX_DELTAX, COMPUTE_VERTEX_DELTAY, COMPUTE_VERTEX_DELTAZ, COMPUTE_VERTEX_TANX, COMPUTE_VERTEX_TANY, COMPUTE_VERTEX_TANZ
    },
    PipelinePassCreateInfo::DescriptorSets{COMPUTE_NORMALS_UBO_SET},
    ClearData{{0.0f, 0.0f, 0.0f, 1.0f}, 1.0f, 0},
    BlendState{},
    RenderPassType::Compute
    });

  const U32 RENDER_PASS = renderPassRequirements.AddPass({
    PipelinePassCreateInfo::Shaders{VERTEX_SHADER_ID, PIXEL_SHADER_ID}, // SHADERS
    PipelinePassCreateInfo::InputTargets{},                             // INPUT TARGETS
    PipelinePassCreateInfo::InputBuffers{},                             // INPUT TARGETS
    PipelinePassCreateInfo::OutputTargets{},                            // OUTPUT TARGETS
    PipelinePassCreateInfo::OutputBuffers{},                            // OUTPUT TARGETS
    PipelinePassCreateInfo::DescriptorSets{UBO_SET, LIGHT_SET, SAMPLER_SET, TEXTURE_SET},         // DESCRIPTORS
    ClearData{{0.1f, 0.1f, 0.1f, 1.0f}, 1.0f, 0}
    });

  std::vector&lt;Vector3f&gt; zeroBufferData = std::vector&lt;Vector3f&gt;(p_activeMesh-&gt;GetVertexCount(), Vector3f(0.0f));
  std::vector&lt;Vector3i&gt; zeroIntVecData = std::vector&lt;Vector3i&gt;(p_activeMesh-&gt;GetVertexCount(), Vector3i(0));
  std::vector&lt;U32&gt; zeroIntBuffer = std::vector&lt;U32&gt;(p_activeMesh-&gt;GetVertexCount(), 0);

  const auto totalConstraints = U32(clothDistanceConstraints.GetSize() + clothBendingConstraints.GetSize() + clothLongRangeConstraints.GetSize());

  m_renderer = RenderSystem::CreateRenderer(appInfo, requirements, applicationRequirements,
    m_window-&gt;GetSwapChainRequirements(), renderPassRequirements,
    descriptorRequirements, shaderRequirements, m_mainAllocator,
    m_drawableAllocator,
    *m_window);

  m_textureManager = RenderSystem::CreateTextureManager(textureRequirements);

  const U32 albedoTexture = m_textureManager-&gt;Load(&quot;Textures/Fabric10_col.jpg&quot;);
  // const U32 albedoTexture = m_textureManager-&gt;Load(&quot;Meshes/CustomCloth2/ClothCustom2_col.jpg&quot;);
  // const U32 albedoTexture = m_textureManager-&gt;Load(&quot;Meshes/Plane/Color plane map.png&quot;);
  const TextureDesc* albedoDesc = m_textureManager-&gt;GetInfo(albedoTexture);
  VERIFY_TRUE(log_AppRenderer, albedoDesc != nullptr, &quot;albedoDesc was Null&quot;);

  const U32 normalTexture = m_textureManager-&gt;Load(&quot;Textures/Fabric10_nrm.jpg&quot;);
  // const U32 normalTexture = m_textureManager-&gt;Load(&quot;Meshes/CustomCloth2/ClothCustom2_nrm.jpg&quot;);
  const TextureDesc* normalDesc = m_textureManager-&gt;GetInfo(normalTexture);
  VERIFY_TRUE(log_AppRenderer, normalDesc != nullptr, &quot;normalDesc was Null&quot;);

  const U32 roughnessTexture = m_textureManager-&gt;Load(&quot;Textures/Fabric10_rgh.jpg&quot;);
  // const U32 roughnessTexture = m_textureManager-&gt;Load(&quot;Meshes/CustomCloth2/ClothCustom2_rgh.jpg&quot;);
  const TextureDesc* roughnessDesc = m_textureManager-&gt;GetInfo(roughnessTexture);
  VERIFY_TRUE(log_AppRenderer, roughnessDesc != nullptr, &quot;roughnessDesc was Null&quot;);

  const U32 aoTexture = m_textureManager-&gt;Load(&quot;Textures/Fabric10_AO.jpg&quot;);
  // const U32 aoTexture = m_textureManager-&gt;Load(&quot;Meshes/CustomCloth2/ClothCustom2_AO.jpg&quot;);
  const TextureDesc* aoDesc = m_textureManager-&gt;GetInfo(aoTexture);
  VERIFY_TRUE(log_AppRenderer, aoDesc != nullptr, &quot;aoDesc was Null&quot;);

  const U32 floorAlbedo = m_textureManager-&gt;Load(&quot;Textures/Concrete10_col.jpg&quot;);
  const TextureDesc* floorAlbedoDesc = m_textureManager-&gt;GetInfo(floorAlbedo);
  VERIFY_TRUE(log_AppRenderer, floorAlbedoDesc != nullptr, &quot;floorAlbedoDesc was Null&quot;);

  const U32 floorNormal = m_textureManager-&gt;Load(&quot;Textures/Concrete10_nrm.jpg&quot;);
  const TextureDesc* floorNormalDesc = m_textureManager-&gt;GetInfo(floorNormal);
  VERIFY_TRUE(log_AppRenderer, floorNormalDesc != nullptr, &quot;floorNormalDesc was Null&quot;);

  const U32 floorAO = m_textureManager-&gt;Load(&quot;Textures/Concrete10_AO.jpg&quot;);
  const TextureDesc* floorAODesc = m_textureManager-&gt;GetInfo(floorAO);
  VERIFY_TRUE(log_AppRenderer, floorAODesc != nullptr, &quot;floorAODesc was Null&quot;);

  const U32 floorRoughness = m_textureManager-&gt;Load(&quot;Textures/Concrete10_rgh.jpg&quot;);
  const TextureDesc* floorRoughnessDesc = m_textureManager-&gt;GetInfo(floorRoughness);
  VERIFY_TRUE(log_AppRenderer, floorRoughnessDesc != nullptr, &quot;floorRoughnessDesc was Null&quot;);

  U32 shehzanId = 0;
  const TextureDesc* shehzanDesc = nullptr;
  if (SHEHZAN &amp;&amp; USE_CURTAIN) {
    shehzanId = m_textureManager-&gt;Load(&quot;Textures/shehzan.jpg&quot;);
    shehzanDesc = m_textureManager-&gt;GetInfo(shehzanId);
    VERIFY_TRUE(log_AppRenderer, shehzanDesc != nullptr, &quot;shehzanDesc was Null&quot;);
  }

  const auto clothParticleMass = reinterpret_cast&lt;const U8*&gt;(p_activeMesh-&gt;GetVertexInverseMass().Data()); // NOLINT
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_INV_MASS, clothParticleMass);

  if (USE_MESH)
  {
    const auto vertexAliases = reinterpret_cast&lt;const U8*&gt;(m_clothMesh.GetVertexAliases().Data()); // NOLINT
    m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_ALIAS_BUFFER, vertexAliases);
  }
  else
  {
    std::vector&lt;int&gt; noAliasBuffer = std::vector&lt;int&gt;(p_activeMesh-&gt;GetVertexCount(), -1);
    const auto vertexAliases = reinterpret_cast&lt;const U8*&gt;(noAliasBuffer.data()); // NOLINT
    m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_ALIAS_BUFFER, vertexAliases);
  }

  const auto clothDataStart = reinterpret_cast&lt;const U8*&gt;(p_activeMesh-&gt;VertexData()); // NOLINT
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_BUFFER, clothDataStart);

  auto clothProperties = ClothComputeProperties();
  clothProperties.m_minBounding = Vector3i(10000, 10000, 10000);
  clothProperties.m_maxBounding = Vector3i(-10000, -10000, -10000);
  const auto clothStart = reinterpret_cast&lt;const U8*&gt;(&amp;clothProperties); // NOLINT
  m_renderer-&gt;BindBufferTarget(COMPUTE_CLOTH_PROPERTIES, clothStart);

  const auto binCountVector = std::vector&lt;U32&gt;(MAX_GRID_RESOLUTION_X * MAX_GRID_RESOLUTION_Y * MAX_GRID_RESOLUTION_Z);
  const auto binVerticesVector = std::vector&lt;U32&gt;(MAX_VERTICES_PER_BIN * MAX_GRID_RESOLUTION_X * MAX_GRID_RESOLUTION_Y * MAX_GRID_RESOLUTION_Z);
  const auto binStart = reinterpret_cast&lt;const U8*&gt;(binCountVector.data()); // NOLINT
  const auto binVerticesStart = reinterpret_cast&lt;const U8*&gt;(binVerticesVector.data()); // NOLINT
  m_renderer-&gt;BindBufferTarget(COMPUTE_GRID_COUNT, binStart);
  m_renderer-&gt;BindBufferTarget(COMPUTE_GRID_VERTICES, binVerticesStart);

  const auto projectionStart = reinterpret_cast&lt;const U8*&gt;(zeroBufferData.data()); // NOLINT
  m_renderer-&gt;BindBufferTarget(COMPUTE_PROJECTION_BUFFER, projectionStart);

  const auto distanceConstraintStart = reinterpret_cast&lt;const U8*&gt;(clothDistanceConstraints.Data()); // NOLINT
  const auto lrConstraintStart = reinterpret_cast&lt;const U8*&gt;(clothLongRangeConstraints.Data()); // NOLINT
  const auto bendConstraintStart = reinterpret_cast&lt;const U8*&gt;(clothBendingConstraints.Data()); // NOLINT
  m_renderer-&gt;BindBufferTarget(DISTANCE_CONSTRAINTS_BUFFER, distanceConstraintStart);
  m_renderer-&gt;BindBufferTarget(LONG_RANGE_CONSTRAINTS_BUFFER, lrConstraintStart);
  m_renderer-&gt;BindBufferTarget(BEND_CONSTRAINTS_BUFFER, bendConstraintStart);

  if (!SCENE_ANGULAR_VELOCITY) {
    const auto velocityStart = reinterpret_cast&lt;const U8*&gt;(zeroBufferData.data()); // NOLINT
    m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_VELOCITY, velocityStart);
  }
  else
  {
    std::vector&lt;Vector3f&gt; radialVelocityBuffer = std::vector&lt;Vector3f&gt;(p_activeMesh-&gt;GetVertexCount(), Vector3f(0.0f));

    for (U32 idx = 0; idx &lt; p_activeMesh-&gt;GetVertexCount(); ++idx) {
      Vector3f radius = clothDataSet[idx] - CLOTH_ORIGIN;
      radialVelocityBuffer[idx] = Vector3f::CrossProduct(ANGULAR_VELOCITY, radius);
    }

    const auto velocityStart = reinterpret_cast&lt;const U8*&gt;(radialVelocityBuffer.data()); // NOLINT
    m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_VELOCITY, velocityStart);
  }

  const auto bufferLock = reinterpret_cast&lt;const U8*&gt;(zeroIntBuffer.data()); // NOLINT
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_CONSTRAINT_COUNT, bufferLock);

  const auto deltaStart = reinterpret_cast&lt;const U8*&gt;(zeroIntBuffer.data()); // NOLINT
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_DELTAX, deltaStart);
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_DELTAY, deltaStart);
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_DELTAZ, deltaStart);

  const auto vertexModelMatrixBufferStart = reinterpret_cast&lt;const U8*&gt;(vertexModelMatrixIdBuffer.data()); // NOLINT
  m_renderer-&gt;BindBufferTarget(COMPUTE_VERTEX_MODEL_MATRICES, vertexModelMatrixBufferStart);

  m_renderer-&gt;BindBufferTarget(COMPUTE_INDEX_BUFFER, p_activeMesh-&gt;IndexData());


  // CREATE COMPUTE POOL - PBD
  const U32 numConstraintBlocks = (totalConstraints + DEFAULT_BLOCK_SIZE_X - 1) / DEFAULT_BLOCK_SIZE_X;
  const U32 numVerticesBlocks = (p_activeMesh-&gt;GetVertexCount() + DEFAULT_BLOCK_SIZE_X - 1) / DEFAULT_BLOCK_SIZE_X;
  const U32 numGridBlocks = ((MAX_GRID_RESOLUTION_X * MAX_GRID_RESOLUTION_Y * MAX_GRID_RESOLUTION_Z) + DEFAULT_BLOCK_SIZE_X - 1) / DEFAULT_BLOCK_SIZE_X;
  const U32 numTriangleBlocks = ((p_activeMesh-&gt;GetIndexCount() / 3) + DEFAULT_BLOCK_SIZE_X - 1) / DEFAULT_BLOCK_SIZE_X;


  ComputePoolCreateInfo pass1 = { allocatorTemporary };
  pass1.m_byteSize = 0xF00000;
  pass1.m_computePasses = { {m_computePass.m_pass1}, allocatorTemporary };
  pass1.m_launchDims = ThreadGroupDimensions{ numVerticesBlocks, 1, 1 };

  ComputePoolCreateInfo passBin = { allocatorTemporary };
  passBin.m_byteSize = 0xF00000;
  passBin.m_computePasses = { {m_computePass.m_passBinning}, allocatorTemporary };
  passBin.m_launchDims = ThreadGroupDimensions{ numVerticesBlocks, 1, 1 };

  ComputePoolCreateInfo passSelfCollisions = { allocatorTemporary };
  passSelfCollisions.m_byteSize = 0xF00000;
  passSelfCollisions.m_computePasses = { {m_computePass.m_passSelfCollisions}, allocatorTemporary };
  passSelfCollisions.m_launchDims = ThreadGroupDimensions{ numTriangleBlocks, 1, 1 };

  ComputePoolCreateInfo passBinInit = { allocatorTemporary };
  passBinInit.m_byteSize = 0xF00000;
  passBinInit.m_computePasses = { {m_computePass.m_passInitialize}, allocatorTemporary };
  passBinInit.m_launchDims = ThreadGroupDimensions{ numGridBlocks , 1, 1 };

  ComputePoolCreateInfo pass3 = { allocatorTemporary };
  pass3.m_byteSize = 0xF00000;
  pass3.m_computePasses = { {m_computePass.m_pass4}, allocatorTemporary };
  pass3.m_launchDims = ThreadGroupDimensions{ numVerticesBlocks, 1, 1 };

  const float distanceStiffnessPrime = 1.0f - std::pow(1.0f - DISTANCE_STIFFNESS, 1.0f / SOLVER_ITERATIONS);
  const float lrStiffnessPrime = 1.0f - std::pow(1.0f - LONG_RANGE_STIFFNESS, 1.0f / SOLVER_ITERATIONS);
  const float bendingStiffnessPrime = 1.0f - std::pow(1.0f - BENDING_STIFFNESS, 1.0f / SOLVER_ITERATIONS);

  m_computeUBO = {};
  m_computeUBO.m_numVertices = p_activeMesh-&gt;GetVertexCount();
  m_computeUBO.m_numTriangles = p_activeMesh-&gt;GetIndexCount() / 3;
  m_computeUBO.m_stretchStiffness = distanceStiffnessPrime;
  m_computeUBO.m_bendStiffness = bendingStiffnessPrime;
  m_computeUBO.m_longRangeStiffness = lrStiffnessPrime;
  m_computeUBO.m_timeDelta = 0.0f;
  m_computeUBO.m_numLongRangeConstraints = U32(clothLongRangeConstraints.GetSize());
  m_computeUBO.m_numStretchConstraints = U32(clothDistanceConstraints.GetSize());
  m_computeUBO.m_numBendConstraints = U32(clothBendingConstraints.GetSize());

  if (USE_CURTAIN)
  {
    for (U32 idx = 0; idx &lt; CURTAIN_ANCHORS; idx++)
    {
      m_computeUBO.m_clothModelMatrix[idx] = m_curtainTransforms[idx].GetTransform();
    }
  }
  else {
    m_computeUBO.m_clothModelMatrix[0] = m_clothTransform.GetTransform().Transpose();
    m_computeUBO.m_clothModelMatrix[1] = m_clothTransform.GetTransform().Transpose();
  }

  const auto computeUBOStart = reinterpret_cast&lt;const U8*&gt;(&amp;m_computeUBO); // NOLINT

  ComputePool&amp; computeProjectedPositions = m_renderer-&gt;CreateComputePool(pass1);
  computeProjectedPositions.AddShader(COMPUTE_1_PBD);
  computeProjectedPositions.BindUniformData(m_computePass.m_computeUBOSlot, computeUBOStart, sizeof(ComputeUBO));
  m_computePools[0] = &amp;computeProjectedPositions;

  ComputePool&amp; computeBinning = m_renderer-&gt;CreateComputePool(passBin);
  computeBinning.AddShader(COMPUTE_2_BINNING);
  computeBinning.BindUniformData(m_computePass.m_computeUBOSlot, computeUBOStart, sizeof(ComputeUBO));
  m_computePools[1] = &amp;computeBinning;

  ComputePool&amp; computeGenSelfCol = m_renderer-&gt;CreateComputePool(passSelfCollisions);
  computeGenSelfCol.AddShader(COMPUTE_SELF_COLLSIONS);
  computeGenSelfCol.BindUniformData(m_computePass.m_computeUBOSlot, computeUBOStart, sizeof(ComputeUBO));
  m_computePools[2] = &amp;computeGenSelfCol;

  ComputePool&amp; computeBinningInit = m_renderer-&gt;CreateComputePool(passBinInit);
  computeBinningInit.AddShader(COMPUTE_2_BINNING_INIT);
  computeBinningInit.BindUniformData(m_computePass.m_computeUBOSlot, computeUBOStart, sizeof(ComputeUBO));
  m_computePools[3] = &amp;computeBinningInit;

  for (U32 idx = 0; idx &lt; SOLVER_ITERATIONS; ++idx) {
    ComputePoolCreateInfo poolInfoConstraints = { allocatorTemporary };
    poolInfoConstraints.m_byteSize = 0xF00000;
    poolInfoConstraints.m_computePasses = { {m_computePass.m_passItr1[idx]}, allocatorTemporary };
    poolInfoConstraints.m_launchDims = ThreadGroupDimensions{ numConstraintBlocks, 1, 1 };

    ComputePool&amp; computeApplyConstraints = m_renderer-&gt;CreateComputePool(poolInfoConstraints);
    computeApplyConstraints.AddShader(COMPUTE_2_PBD);
    computeApplyConstraints.BindUniformData(m_computePass.m_computeUBOSlot, computeUBOStart, sizeof(ComputeUBO));
    m_iterativePools.push_back(&amp;computeApplyConstraints);

    ComputePoolCreateInfo pass2 = { allocatorTemporary };
    pass2.m_byteSize = 0xF00000;
    pass2.m_computePasses = { {m_computePass.m_passItr2[idx]}, allocatorTemporary };
    pass2.m_launchDims = ThreadGroupDimensions{ numVerticesBlocks, 1, 1 };

    ComputePool&amp; computeApplyDelta = m_renderer-&gt;CreateComputePool(pass2);
    computeApplyDelta.AddShader(COMPUTE_3_PBD);
    computeApplyDelta.BindUniformData(m_computePass.m_computeUBOSlot, computeUBOStart, sizeof(ComputeUBO));
    m_iterativePools.push_back(&amp;computeApplyDelta);
  }

  ComputePool&amp; computeComputePositions = m_renderer-&gt;CreateComputePool(pass3);
  computeComputePositions.AddShader(COMPUTE_4_PBD);
  computeComputePositions.BindUniformData(m_computePass.m_computeUBOSlot, computeUBOStart, sizeof(ComputeUBO));
  m_computePools[4] = &amp;computeComputePositions;

  // CREATE COMPUTE POOL - NORMALS
  const U32 numBlocksForNormalize = (m_normalUBO.m_numTriangles + DEFAULT_BLOCK_SIZE_X - 1) / DEFAULT_BLOCK_SIZE_X;

  ComputePoolCreateInfo normComputePoolInfo = { allocatorTemporary };
  normComputePoolInfo.m_byteSize = 0xF00000;
  normComputePoolInfo.m_computePasses = { {m_normalsPass.m_passId}, allocatorTemporary };
  normComputePoolInfo.m_launchDims = ThreadGroupDimensions{ numBlocksForNormalize, 1, 1 };

  ComputePool&amp; normComputePool = m_renderer-&gt;CreateComputePool(normComputePoolInfo);
  const auto normUBOStart = reinterpret_cast&lt;const U8*&gt;(&amp;m_normalUBO); // NOLINT
  normComputePool.BindUniformData(m_normalsPass.m_uboSlot, normUBOStart, sizeof(NormalUBO));

  IcoSphere sphere(4);
  Plane plane(Vector2f(-150, -150), Vector2f(150, 150), Vector2u(10, 10), Vector2u(10, 10));
  Plane shehzanPlane(Vector2f(-5, -5), Vector2f(5, 5), Vector2u(2, 2), Vector2u(1, 1));

  DrawablePoolCreateInfo poolInfo = { allocatorTemporary };
  poolInfo.m_byteSize = sphere.TotalDataSize() + p_activeMesh-&gt;TotalDataSize() + TEXTURE_MEMORY + 0x400000;
  poolInfo.m_numDrawables = 2;
  poolInfo.m_renderPasses = { {RENDER_PASS}, allocatorTemporary };
  poolInfo.m_drawType = DrawType::InstancedIndexed;

  const auto VERTEX_SLOT = poolInfo.AddInputSlot({
    BufferUsageRate::PerVertex, {{&quot;POSITION&quot;, p_activeMesh-&gt;GetVertexFormat()}}, 0, BufferSource::StructuredBuffer
    });

  const auto UV_SLOT = poolInfo.AddInputSlot({
    BufferUsageRate::PerVertex, {{&quot;UV&quot;, p_activeMesh-&gt;GetUVFormat()}}
    });

  const auto NORMAL_SLOT_X = poolInfo.AddInputSlot({
    BufferUsageRate::PerVertex, {{&quot;NORMALX&quot;, RawStorageFormat::R32_UINT}}, 0, BufferSource::StructuredBuffer
    });

  const auto NORMAL_SLOT_Y = poolInfo.AddInputSlot({
    BufferUsageRate::PerVertex, {{&quot;NORMALY&quot;, RawStorageFormat::R32_UINT}}, 0, BufferSource::StructuredBuffer
    });

  const auto NORMAL_SLOT_Z = poolInfo.AddInputSlot({
    BufferUsageRate::PerVertex, {{&quot;NORMALZ&quot;, RawStorageFormat::R32_UINT}}, 0, BufferSource::StructuredBuffer
    });

  const auto TANGENT_SLOT_X = poolInfo.AddInputSlot({
    BufferUsageRate::PerVertex, {{&quot;TANGENTX&quot;, RawStorageFormat::R32_UINT}}, 0, BufferSource::StructuredBuffer
    });

  const auto TANGENT_SLOT_Y = poolInfo.AddInputSlot({
    BufferUsageRate::PerVertex, {{&quot;TANGENTY&quot;, RawStorageFormat::R32_UINT}}, 0, BufferSource::StructuredBuffer
    });

  const auto TANGENT_SLOT_Z = poolInfo.AddInputSlot({
    BufferUsageRate::PerVertex, {{&quot;TANGENTZ&quot;, RawStorageFormat::R32_UINT}}, 0, BufferSource::StructuredBuffer
    });

  DrawablePool&amp; clothPool = m_renderer-&gt;CreateDrawablePool(poolInfo);

  const auto uboDataBuffer = reinterpret_cast&lt;U8*&gt;(&amp;m_clothUBO);  // NOLINT
  const auto sphereUBO = reinterpret_cast&lt;U8*&gt;(&amp;m_sphereUBO); // NOLINT
  const auto planeUBO = reinterpret_cast&lt;U8*&gt;(&amp;m_planeUBO); // NOLINT
  const auto shehzanUBO = reinterpret_cast&lt;U8*&gt;(&amp;m_shehzanUBO); // NOLINT
  const auto lightDataBuffer = reinterpret_cast&lt;U8*&gt;(&amp;lightData);   // NOLINT
  // Create Drawable from Pool
  DrawableCreateInfo createInfo = {};
  createInfo.m_vertexCount = p_activeMesh-&gt;GetVertexCount();
  createInfo.m_indexCount = p_activeMesh-&gt;GetIndexCount();
  createInfo.m_instanceCount = 1;
  createInfo.m_indexType = RawStorageFormat::R32_UINT;

  SamplerDesc desc = {};
  desc.m_filter = TextureFilter::MinMagMipLinear;
  desc.m_addressModeU = TextureAddressMode::Wrap;
  desc.m_addressModeV = TextureAddressMode::Wrap;
  desc.m_addressModeW = TextureAddressMode::Wrap;
  clothPool.BindSampler(SAMPLER_SLOT, desc);
  clothPool.BindTextureData(TEXTURE_SLOT, *albedoDesc, m_textureManager-&gt;GetData(albedoTexture));
  clothPool.BindTextureData(NORMALS_SLOT, *normalDesc, m_textureManager-&gt;GetData(normalTexture));
  clothPool.BindTextureData(ROUGHNESS_SLOT, *roughnessDesc, m_textureManager-&gt;GetData(roughnessTexture));
  clothPool.BindTextureData(AO_SLOT, *aoDesc, m_textureManager-&gt;GetData(aoTexture));

  const auto clothId = clothPool.CreateDrawable(createInfo);
  clothPool.BindVertexData(clothId, VERTEX_SLOT, COMPUTE_VERTEX_BUFFER, 0, p_activeMesh-&gt;VertexDataSize());
  clothPool.BindVertexData(clothId, UV_SLOT, p_activeMesh-&gt;UVData(), p_activeMesh-&gt;UVDataSize());
  clothPool.BindVertexData(clothId, NORMAL_SLOT_X, COMPUTE_VERTEX_DELTAX, 0, p_activeMesh-&gt;GetVertexCount() * U32(sizeof(float)));
  clothPool.BindVertexData(clothId, NORMAL_SLOT_Y, COMPUTE_VERTEX_DELTAY, 0, p_activeMesh-&gt;GetVertexCount() * U32(sizeof(float)));
  clothPool.BindVertexData(clothId, NORMAL_SLOT_Z, COMPUTE_VERTEX_DELTAZ, 0, p_activeMesh-&gt;GetVertexCount() * U32(sizeof(float)));
  clothPool.BindVertexData(clothId, TANGENT_SLOT_X, COMPUTE_VERTEX_TANX, 0, p_activeMesh-&gt;GetVertexCount() * U32(sizeof(float)));
  clothPool.BindVertexData(clothId, TANGENT_SLOT_Y, COMPUTE_VERTEX_TANY, 0, p_activeMesh-&gt;GetVertexCount() * U32(sizeof(float)));
  clothPool.BindVertexData(clothId, TANGENT_SLOT_Z, COMPUTE_VERTEX_TANZ, 0, p_activeMesh-&gt;GetVertexCount() * U32(sizeof(float)));
  clothPool.SetIndexData(clothId, p_activeMesh-&gt;IndexData(), p_activeMesh-&gt;IndexDataSize());
  clothPool.BindUniformData(clothId, UBO_SLOT, uboDataBuffer, sizeof(SceneUBO));
  clothPool.BindUniformData(clothId, LIGHT_SLOT, lightDataBuffer, sizeof(LightData));

  DrawableCreateInfo sphereDrawableInfo = {};
  sphereDrawableInfo.m_vertexCount = sphere.GetVertexCount();
  sphereDrawableInfo.m_indexCount = sphere.GetIndexCount();
  sphereDrawableInfo.m_instanceCount = 1;
  sphereDrawableInfo.m_indexType = sphere.GetIndexFormat();

  DrawableCreateInfo planeDrawableInfo = {};
  planeDrawableInfo.m_vertexCount = plane.GetVertexCount();
  planeDrawableInfo.m_indexCount = plane.GetIndexCount();
  planeDrawableInfo.m_instanceCount = 1;
  planeDrawableInfo.m_indexType = plane.GetIndexFormat();

  DrawableCreateInfo shehzanPlaneDrawableInfo = {};
  shehzanPlaneDrawableInfo.m_vertexCount = shehzanPlane.GetVertexCount();
  shehzanPlaneDrawableInfo.m_indexCount = shehzanPlane.GetIndexCount();
  shehzanPlaneDrawableInfo.m_instanceCount = 1;
  shehzanPlaneDrawableInfo.m_indexType = shehzanPlane.GetIndexFormat();

  if (RENDER_SPHERE) {
    DrawablePoolCreateInfo spherePoolInfo = { allocatorTemporary };
    spherePoolInfo.m_byteSize = sphere.TotalDataSize() + 0x400000;
    spherePoolInfo.m_numDrawables = 1;
    spherePoolInfo.m_renderPasses = { {RENDER_PASS}, allocatorTemporary };
    spherePoolInfo.m_drawType = DrawType::InstancedIndexed;

    const auto SPHERE_VERTEX_SLOT = spherePoolInfo.AddInputSlot({
      BufferUsageRate::PerVertex, {{&quot;POSITION&quot;, RawStorageFormat::R32G32B32A32_FLOAT}}
      });

    const auto SPHERE_NORMAL_SLOT = spherePoolInfo.AddInputSlot({
      BufferUsageRate::PerVertex, {{&quot;NORMAL&quot;, RawStorageFormat::R32G32B32_FLOAT}}
      });

    DrawablePool&amp; spherePool = m_renderer-&gt;CreateDrawablePool(spherePoolInfo);
    spherePool.AddShader(SPHERE_VERTEX_SHADER_ID);
    spherePool.AddShader(SPHERE_PIXEL_SHADER_ID);

    const auto sphereId = spherePool.CreateDrawable(sphereDrawableInfo);
    spherePool.BindVertexData(sphereId, SPHERE_VERTEX_SLOT, sphere.VertexData(), sphere.VertexDataSize());
    spherePool.BindVertexData(sphereId, SPHERE_NORMAL_SLOT, sphere.NormalData(), sphere.NormalDataSize());
    spherePool.SetIndexData(sphereId, sphere.IndexData(), sphere.IndexDataSize());
    spherePool.BindUniformData(sphereId, UBO_SLOT, sphereUBO, sizeof(SceneUBO));
    spherePool.BindUniformData(sphereId, LIGHT_SLOT, lightDataBuffer, sizeof(LightData));

    m_renderPass.m_sphereId     = sphereId;
    m_spherePool = &amp;spherePool;
  }

  SamplerDesc floorSampler = {};
  floorSampler.m_filter = TextureFilter::MinMagMipLinear;
  floorSampler.m_addressModeU = TextureAddressMode::Wrap;
  floorSampler.m_addressModeV = TextureAddressMode::Wrap;
  floorSampler.m_addressModeW = TextureAddressMode::Wrap;

  if (RENDER_FLOOR_PLANE) {
    DrawablePoolCreateInfo planePoolInfo = { allocatorTemporary };
    planePoolInfo.m_byteSize = plane.TotalDataSize() + 0x800000;
    planePoolInfo.m_numDrawables = 1;
    planePoolInfo.m_renderPasses = { {RENDER_PASS}, allocatorTemporary };
    planePoolInfo.m_drawType = DrawType::InstancedIndexed;

    const auto PLANE_VERTEX_SLOT = planePoolInfo.AddInputSlot({
      BufferUsageRate::PerVertex, {{&quot;POSITION&quot;, plane.GetVertexFormat()}}
      });

    const auto PLANE_NORMAL_SLOT = planePoolInfo.AddInputSlot({
      BufferUsageRate::PerVertex, {{&quot;NORMAL&quot;, plane.GetNormalFormat()}}
      });

    const auto PLANE_UV_SLOT = planePoolInfo.AddInputSlot({
      BufferUsageRate::PerVertex, {{&quot;UV&quot;, plane.GetUVFormat()}}
      });

    DrawablePool&amp; planePool = m_renderer-&gt;CreateDrawablePool(planePoolInfo);
    planePool.AddShader(PLANE_VERTEX_SHADER_ID);
    planePool.AddShader(PLANE_PIXEL_SHADER_ID);

    planePool.BindSampler(SAMPLER_SLOT, floorSampler);
    planePool.BindTextureData(TEXTURE_SLOT, *floorAlbedoDesc, m_textureManager-&gt;GetData(floorAlbedo));
    planePool.BindTextureData(NORMALS_SLOT, *floorNormalDesc, m_textureManager-&gt;GetData(floorNormal));
    planePool.BindTextureData(ROUGHNESS_SLOT, *floorRoughnessDesc, m_textureManager-&gt;GetData(floorRoughness));
    planePool.BindTextureData(AO_SLOT, *floorAODesc, m_textureManager-&gt;GetData(floorAO));

    const auto planeId = planePool.CreateDrawable(planeDrawableInfo);
    planePool.BindVertexData(planeId, PLANE_VERTEX_SLOT, plane.VertexData(), plane.VertexDataSize());
    planePool.BindVertexData(planeId, PLANE_NORMAL_SLOT, plane.NormalData(), plane.NormalDataSize());
    planePool.BindVertexData(planeId, PLANE_UV_SLOT, plane.UVData(), plane.UVDataSize());
    planePool.SetIndexData(planeId, plane.IndexData(), plane.IndexDataSize());
    planePool.BindUniformData(planeId, UBO_SLOT, planeUBO, sizeof(SceneUBO));
    planePool.BindUniformData(planeId, LIGHT_SLOT, lightDataBuffer, sizeof(LightData));

    m_renderPass.m_planeId      = planeId;
    m_planePool = &amp;planePool;
  }

   if (SHEHZAN &amp;&amp; USE_CURTAIN) {
     DrawablePoolCreateInfo shehzanPoolInfo = { allocatorTemporary };
     shehzanPoolInfo.m_byteSize = shehzanPlane.TotalDataSize() + 0x800000;
     shehzanPoolInfo.m_numDrawables = 1;
     shehzanPoolInfo.m_renderPasses = { {RENDER_PASS}, allocatorTemporary };
     shehzanPoolInfo.m_drawType = DrawType::InstancedIndexed;

     const auto SHEHZAN_VERTEX_SLOT = shehzanPoolInfo.AddInputSlot({
       BufferUsageRate::PerVertex, {{&quot;POSITION&quot;, shehzanPlane.GetVertexFormat()}}
       });

     const auto SHEHZAN_NORMAL_SLOT = shehzanPoolInfo.AddInputSlot({
       BufferUsageRate::PerVertex, {{&quot;NORMAL&quot;, shehzanPlane.GetNormalFormat()}}
       });

     const auto SHEHZAN_UV_SLOT = shehzanPoolInfo.AddInputSlot({
       BufferUsageRate::PerVertex, {{&quot;UV&quot;, shehzanPlane.GetUVFormat()}}
       });

     DrawablePool&amp; shehzanPool = m_renderer-&gt;CreateDrawablePool(shehzanPoolInfo);
     shehzanPool.AddShader(SHEHZAN_VERTEX_SHADER_ID);
     shehzanPool.AddShader(SHEHZAN_PIXEL_SHADER_ID);

     shehzanPool.BindSampler(SAMPLER_SLOT, floorSampler);
     shehzanPool.BindTextureData(TEXTURE_SLOT, *shehzanDesc, m_textureManager-&gt;GetData(shehzanId));

     const auto shehzanPlaneId = shehzanPool.CreateDrawable(shehzanPlaneDrawableInfo);
     shehzanPool.BindVertexData(shehzanPlaneId, SHEHZAN_VERTEX_SLOT, shehzanPlane.VertexData(), shehzanPlane.VertexDataSize());
     shehzanPool.BindVertexData(shehzanPlaneId, SHEHZAN_NORMAL_SLOT, shehzanPlane.NormalData(), shehzanPlane.NormalDataSize());
     shehzanPool.BindVertexData(shehzanPlaneId, SHEHZAN_UV_SLOT, shehzanPlane.UVData(), shehzanPlane.UVDataSize());
     shehzanPool.SetIndexData(shehzanPlaneId, shehzanPlane.IndexData(), shehzanPlane.IndexDataSize());
     shehzanPool.BindUniformData(shehzanPlaneId, UBO_SLOT, shehzanUBO, sizeof(SceneUBO));
     shehzanPool.BindUniformData(shehzanPlaneId, LIGHT_SLOT, lightDataBuffer, sizeof(LightData));

     m_shehzanPool = &amp;shehzanPool;
     m_renderPass.m_shehzanId = shehzanPlaneId;
   }

  m_renderPass.m_vertexSlot   = VERTEX_SLOT;
  m_renderPass.m_sceneUBOSlot = UBO_SLOT;
  m_renderPass.m_clothId      = clothId;

  m_mainPool   = &amp;clothPool;

  // All Drawables Done
  m_renderer-&gt;Submit();

  LOG_INF(log_AppRenderer, LOG_LEVEL, &quot;Initialized AppRenderer&quot;);
}

void AppRenderer::WindowUpdate(float timeDelta) {
  if (timeDelta &lt; EPSILON) {
    return;
  }

  m_camera.Update(timeDelta);
  m_clothTransform.Update(timeDelta);

  m_clothUBO.m_view              = m_camera.GetViewMatrix();
  m_clothUBO.m_viewProj          = m_camera.GetViewProjMatrix();
  m_clothUBO.m_invViewProj       = m_camera.GetInvViewProjMatrix();
  m_clothUBO.m_invProj           = m_camera.GetProjMatrix().Inverse();
  m_clothUBO.m_modelInvTranspose = m_clothUBO.m_model.Inverse().Transpose();

  m_sphereUBO.m_view              = m_camera.GetViewMatrix();
  m_sphereUBO.m_viewProj          = m_camera.GetViewProjMatrix();
  m_sphereUBO.m_invViewProj       = m_camera.GetInvViewProjMatrix();
  m_sphereUBO.m_invProj           = m_camera.GetProjMatrix().Inverse();
  m_sphereUBO.m_modelInvTranspose = m_sphereUBO.m_model.Inverse().Transpose();

  m_planeUBO.m_view = m_camera.GetViewMatrix();
  m_planeUBO.m_viewProj = m_camera.GetViewProjMatrix();
  m_planeUBO.m_invViewProj = m_camera.GetInvViewProjMatrix();
  m_planeUBO.m_invProj = m_camera.GetProjMatrix().Inverse();
  m_planeUBO.m_modelInvTranspose = m_planeUBO.m_model.Inverse().Transpose();

  m_shehzanUBO.m_view = m_camera.GetViewMatrix();
  m_shehzanUBO.m_viewProj = m_camera.GetViewProjMatrix();
  m_shehzanUBO.m_invViewProj = m_camera.GetInvViewProjMatrix();
  m_shehzanUBO.m_invProj = m_camera.GetProjMatrix().Inverse();
  m_shehzanUBO.m_modelInvTranspose = m_shehzanUBO.m_model.Inverse().Transpose();

  m_computeUBO.m_timeDelta = timeDelta;
  m_computeUBO.m_frameCount++;

  if (USE_CURTAIN)
  {
    for (U32 idx = 0; idx &lt; CURTAIN_ANCHORS; idx++)
    {
      m_curtainTransforms[idx].Update(timeDelta);
      m_computeUBO.m_clothModelMatrix[idx] = m_curtainTransforms[idx].GetTransform();
    }
  }
  else {
    if (SCENE_TWIST)
    {
      Matrix4f rotationDelta0 = Matrix4f::Identity();
      Matrix4f rotationDelta1 = Matrix4f::Identity();
      if (m_rotateFactor != 0) {
        const float rotateAmount = m_rotateFactor * m_rotateStepSize * timeDelta;

        rotationDelta0 = Matrix4f::FromRotationMatrix(Matrix3f::RotationX(rotateAmount));
        rotationDelta1 = Matrix4f::FromRotationMatrix(Matrix3f::RotationX(-rotateAmount));
      }

      m_computeUBO.m_clothModelMatrix[0] = rotationDelta0 * m_clothTransform.GetTransform();
      m_computeUBO.m_clothModelMatrix[1] = rotationDelta1 * m_clothTransform.GetTransform();
    }
    else {
      m_computeUBO.m_clothModelMatrix[0] = m_clothTransform.GetTransform();
      m_computeUBO.m_clothModelMatrix[1] = m_clothTransform.GetTransform();
    }
  }

  const auto uboDataBuffer    = reinterpret_cast&lt;U8*&gt;(&amp;m_clothUBO);         // NOLINT
  const auto sphereDataBuffer = reinterpret_cast&lt;U8*&gt;(&amp;m_sphereUBO);        // NOLINT
  const auto planeDataBuffer = reinterpret_cast&lt;U8*&gt;(&amp;m_planeUBO);        // NOLINT
  const auto shehzanUBOStart = reinterpret_cast&lt;U8*&gt;(&amp;m_shehzanUBO);        // NOLINT
  const auto computeUBOStart  = reinterpret_cast&lt;const U8*&gt;(&amp;m_computeUBO); // NOLINT

  for (auto&amp; computePool : m_computePools) {
    computePool-&gt;BeginUpdates();
    computePool-&gt;UpdateUniformData(m_computePass.m_computeUBOSlot, computeUBOStart, sizeof(ComputeUBO));
    computePool-&gt;SubmitUpdates();
  }

  for (auto&amp; computePool : m_iterativePools) {
    computePool-&gt;BeginUpdates();
    computePool-&gt;UpdateUniformData(m_computePass.m_computeUBOSlot, computeUBOStart, sizeof(ComputeUBO));
    computePool-&gt;SubmitUpdates();
  }

  m_mainPool-&gt;BeginUpdates();
  // Update Cloth
  m_mainPool-&gt;UpdateUniformData(m_renderPass.m_clothId, m_renderPass.m_sceneUBOSlot, uboDataBuffer, sizeof(SceneUBO));
  m_mainPool-&gt;SubmitUpdates();

  if (RENDER_SPHERE) {
    m_spherePool-&gt;BeginUpdates();
    m_spherePool-&gt;UpdateUniformData(m_renderPass.m_sphereId, m_renderPass.m_sceneUBOSlot, sphereDataBuffer,
      sizeof(SceneUBO));
    m_spherePool-&gt;SubmitUpdates();
  }

   if (RENDER_FLOOR_PLANE) {
     m_planePool-&gt;BeginUpdates();
     m_planePool-&gt;UpdateUniformData(m_renderPass.m_planeId, m_renderPass.m_sceneUBOSlot, planeDataBuffer,
       sizeof(SceneUBO));
     m_planePool-&gt;SubmitUpdates();
   }

   if (SHEHZAN &amp;&amp; USE_CURTAIN) {
     m_shehzanPool-&gt;BeginUpdates();
     m_shehzanPool-&gt;UpdateUniformData(m_renderPass.m_shehzanId, m_renderPass.m_sceneUBOSlot, shehzanUBOStart, sizeof(SceneUBO));
     m_shehzanPool-&gt;SubmitUpdates();
   }

  m_renderer-&gt;RenderFrame();
}

void AppRenderer::Run() const {
  LOG_INF(log_AppRenderer, LOG_LEVEL, &quot;Running AppRenderer&quot;);
  m_window-&gt;StartListening();
}

void AppRenderer::Destroy() const {
  m_window-&gt;Destroy();
}
} // namespace Azura
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="file_Source_Samples_0_TestZone_Src_AppRenderer.Deferred.cpp.html" class="btn btn-neutral float-right" title="File AppRenderer.Deferred.cpp" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="file_Source_Samples_3_ClothSim_Src_AppRenderer.cpp.html" class="btn btn-neutral" title="File AppRenderer.cpp" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Vasu Mahesh

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/collapsible-lists\js\CollapsibleLists.compressed.js"></script>
        <script type="text/javascript" src="../_static/collapsible-lists\js\apply-collapsible-lists.js"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>